<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>利用 Const Generics 实现编译期量纲分析 - Ionizing Radiation</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="Ionizing"><meta name=description content=" 什么是量纲分析 什么是 Const Generics 如何使用 Const Generics 实现量纲分析  运行期量纲分析 利用 const generics 实现编译期的量纲分析  SiUnit 的编译期运算 PhysicalQuantity 的加减法运算 PhysicalQuantity 的乘除法运算 PhysicalQuantity 的乘方开方运算 无量纲数及常系数的特殊处理 其它实现     总结  开学前折腾了一段时间的 Rust const generics ，也读了一些前人的代码，并自己写出了自己的编译期量纲分析代码， 因此吸收总结这一过程所得知识，产生了这篇博文。本文的实现全部代码在这里。
"><meta name=keywords content="PhysicalChemistry,ComputerScience"><meta name=generator content="Hugo 0.82.0"><link rel=canonical href=http://ionizing.page/post/dimensional-analysis-using-const-generics/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.f7440b5c0d223f47a09bf5853465434e6f91d80a591c2f8d2d5e8220e5db0580.css integrity="sha256-90QLXA0iP0egm/WFNGVDTm+R2ApZHC+NLV6CIOXbBYA=" media=screen crossorigin=anonymous><meta property="og:title" content="利用 Const Generics 实现编译期量纲分析"><meta property="og:description" content="


什么是量纲分析
什么是 Const Generics
如何使用 Const Generics 实现量纲分析

运行期量纲分析
利用 const generics 实现编译期的量纲分析

SiUnit 的编译期运算
PhysicalQuantity 的加减法运算
PhysicalQuantity 的乘除法运算
PhysicalQuantity 的乘方开方运算
无量纲数及常系数的特殊处理
其它实现




总结


开学前折腾了一段时间的 Rust const generics ，也读了一些前人的代码，并自己写出了自己的编译期量纲分析代码，
因此吸收总结这一过程所得知识，产生了这篇博文。本文的实现全部代码在这里。"><meta property="og:type" content="article"><meta property="og:url" content="http://ionizing.page/post/dimensional-analysis-using-const-generics/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-05T11:59:00+08:00"><meta property="article:modified_time" content="2023-03-05T11:59:00+08:00"><meta itemprop=name content="利用 Const Generics 实现编译期量纲分析"><meta itemprop=description content="


什么是量纲分析
什么是 Const Generics
如何使用 Const Generics 实现量纲分析

运行期量纲分析
利用 const generics 实现编译期的量纲分析

SiUnit 的编译期运算
PhysicalQuantity 的加减法运算
PhysicalQuantity 的乘除法运算
PhysicalQuantity 的乘方开方运算
无量纲数及常系数的特殊处理
其它实现




总结


开学前折腾了一段时间的 Rust const generics ，也读了一些前人的代码，并自己写出了自己的编译期量纲分析代码，
因此吸收总结这一过程所得知识，产生了这篇博文。本文的实现全部代码在这里。"><meta itemprop=datePublished content="2023-03-05T11:59:00+08:00"><meta itemprop=dateModified content="2023-03-05T11:59:00+08:00"><meta itemprop=wordCount content="7263"><meta itemprop=keywords content="Posts,Rust,ConstGenerics,"><meta name=twitter:card content="summary"><meta name=twitter:title content="利用 Const Generics 实现编译期量纲分析"><meta name=twitter:description content="


什么是量纲分析
什么是 Const Generics
如何使用 Const Generics 实现量纲分析

运行期量纲分析
利用 const generics 实现编译期的量纲分析

SiUnit 的编译期运算
PhysicalQuantity 的加减法运算
PhysicalQuantity 的乘除法运算
PhysicalQuantity 的乘方开方运算
无量纲数及常系数的特殊处理
其它实现




总结


开学前折腾了一段时间的 Rust const generics ，也读了一些前人的代码，并自己写出了自己的编译期量纲分析代码，
因此吸收总结这一过程所得知识，产生了这篇博文。本文的实现全部代码在这里。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>IonizingRadiation</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=http://ionizing.page/>Home</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://ionizing.page/post/>Archives</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://ionizing.page/tags/>Tags</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://ionizing.page/categories/>Categories</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://ionizing.page/about/>About</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://ionizing.page/external-link/>External-link</a></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class="header container"><div class=logo-wrapper><a href=/ class=logo>IonizingRadiation</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=http://ionizing.page/>Home</a></li><li class=menu-item><a class=menu-item-link href=http://ionizing.page/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=http://ionizing.page/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=http://ionizing.page/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=http://ionizing.page/about/>About</a></li><li class=menu-item><a class=menu-item-link href=http://ionizing.page/external-link/>External-link</a></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight"><div class=content-wrapper><div id=content class="content container"><article class="post bg-white"><header class=post-header><h1 class=post-title>利用 Const Generics 实现编译期量纲分析</h1><div class=post-meta><time datetime=2023-03-05 class=post-time>2023-03-05</time><div class=post-category><a href=http://ionizing.page/categories/programming/>Programming</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#什么是量纲分析>什么是量纲分析</a></li><li><a href=#什么是-const-generics>什么是 Const Generics</a></li><li><a href=#如何使用-const-generics-实现量纲分析>如何使用 Const Generics 实现量纲分析</a><ul><li><a href=#运行期量纲分析>运行期量纲分析</a></li><li><a href=#利用-const-generics-实现编译期的量纲分析>利用 const generics 实现编译期的量纲分析</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class=post-content><ul><li><a href=#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8F%E7%BA%B2%E5%88%86%E6%9E%90>什么是量纲分析</a></li><li><a href=#%E4%BB%80%E4%B9%88%E6%98%AF-const-generics>什么是 Const Generics</a></li><li><a href=#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-const-generics-%E5%AE%9E%E7%8E%B0%E9%87%8F%E7%BA%B2%E5%88%86%E6%9E%90>如何使用 Const Generics 实现量纲分析</a><ul><li><a href=#%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%87%8F%E7%BA%B2%E5%88%86%E6%9E%90>运行期量纲分析</a></li><li><a href=#%E5%88%A9%E7%94%A8-const-generics-%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E6%9C%9F%E7%9A%84%E9%87%8F%E7%BA%B2%E5%88%86%E6%9E%90>利用 const generics 实现编译期的量纲分析</a><ul><li><a href=#siunit-%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E8%BF%90%E7%AE%97><code>SiUnit</code> 的编译期运算</a></li><li><a href=#physicalquantity-%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97><code>PhysicalQuantity</code> 的加减法运算</a></li><li><a href=#physicalquantity-%E7%9A%84%E4%B9%98%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97><code>PhysicalQuantity</code> 的乘除法运算</a></li><li><a href=#physicalquantity-%E7%9A%84%E4%B9%98%E6%96%B9%E5%BC%80%E6%96%B9%E8%BF%90%E7%AE%97><code>PhysicalQuantity</code> 的乘方开方运算</a></li><li><a href=#%E6%97%A0%E9%87%8F%E7%BA%B2%E6%95%B0%E5%8F%8A%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86>无量纲数及常系数的特殊处理</a></li><li><a href=#%E5%85%B6%E5%AE%83%E5%AE%9E%E7%8E%B0>其它实现</a></li></ul></li></ul></li><li><a href=#%E6%80%BB%E7%BB%93>总结</a></li></ul><p>开学前折腾了一段时间的 Rust const generics ，也读了一些前人的代码，并自己写出了自己的编译期量纲分析代码，
因此吸收总结这一过程所得知识，产生了这篇博文。本文的实现全部代码在<a href="https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=4807be24f1e6493bcc5c7cb86457439c">这里</a>。</p><h2 id=什么是量纲分析>什么是量纲分析</h2><p>这里浅薄地介绍一下什么是量纲分析。贴一下 Wiki<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> 上关于量纲和量纲分析的定义：</p><ol><li>量纲是表示一个物理量由基本量组成的情况。确定若干个基本量后，每个派生量都可以表示为基本量的幂的乘积的形式，
引入量纲分析可以进行量纲分析，这既是物理学的基础，又有很多重要的应用。通常一个物理量的量纲是由像质量、
长度、时间、电荷量、温度一类的基础量纲结合而成；</li><li>量纲分析是指对数学或者物理学中物理量的量纲可以用来分析或检验几个物理量之间的关系。
在判断一个由推导获得的方程式或计算结果是否合理时，可以对等号两边的量纲进行化简，从而确认是否一致，这个过程
即用到了量纲分析。对于较为复杂的情况，量纲分析也可以用来建立合理的假设，然后用严格的实验加以验证，或用已
发展成功的理论来仔细推敲。</li></ol><p>由于目前的基本物理量有七个，故在量纲中分别用七个字母表示它们的量纲，分别为：</p><ul><li>长度（L）</li><li>质量（M）</li><li>温度（Θ）</li><li>电流（I）</li><li>时间（T）</li><li>物质的量（N）</li><li>发光强度（J）</li></ul><p>任何一个物理量 \(A\) 都可以写出下列量纲式：
\[
\text{dim} A = L^{\alpha} M^{\beta} \Theta^{\gamma} I^{\delta} T^{\epsilon} N^{\zeta} J^{\eta}
\]
如果一个物理量的量纲中所有的指数为 0 ，那么称它为无量纲量，常见的无量纲量有精细结构常数 \(\alpha \approx 1/137\) 、
雷诺数 \(\text{Re} = \frac{\rho VL}{\mu} = \frac{VL}{\nu}\) 以及各种比值、概率等。
两个物理量量纲一致是它们能够相加减的必要条件，而不是充要条件，比如力矩和能量的量纲都是 \(F \cdot L\) ，但这两个量显然无法相加减。物理量的乘除乘方开方则没有这个限制，直接按照相应的代数运算法则对各个基本量纲处理再化简即可。</p><p>值得注意的是，能放在指数和真数位置上的物理量一定是无量纲量。回想一下统计力学中几乎无处不在的
\( \frac{E}{k_{\mathrm{B}} T}\) ，其中分母 \(k_B T\) 的量纲是能量，刚好与分子上 \(E\) 相抵消，导致指数整体是一个无量纲量，进而使得 \( \frac{E}{k_{\mathrm{B}} T}\) 这个整体也是一个无量纲量；又比如在化学反应中常见的公式
\(\Delta G = \Delta G^{\ominus} + RT \ln K\) ，其中化学平衡常数 \(K\) 处于真数的位置，它一定是一个无量纲量。</p><p>此时，我们可以大致总结一下量纲分析运算的规则：</p><ol><li>物理量的量纲由 7 个基本量纲构成；</li><li>具有相同量纲的物理量才能相加减；</li><li>物理量在乘除、乘方和开方时基本量纲的指数遵循代数运算法则；</li><li>处于指数、真数位置的物理量是无量纲量。</li></ol><p>这些规则是我们程序实现量纲分析的参考。</p><h2 id=什么是-const-generics>什么是 Const Generics</h2><p>Const generics 翻译过来即为常量泛型。在涉及 Rust 泛型代码时，如果泛型参数是一个常量值，而不是类型或生命周期参数等，那么这个泛型参数就称为常量泛型参数<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。
例如下面一段代码就用到了泛型参数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>Position</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>N</span>: <span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>    </span><span class=c1>// N 即为常量泛型参数
</span><span class=c1></span><span class=w>    </span><span class=n>pos</span>: <span class=p>[</span><span class=n>T</span><span class=p>;</span><span class=w> </span><span class=n>N</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>上面代码中 <code>const N: usize</code> 中的 <code>const</code> 前缀很贴心地告诉你后面的 <code>N</code> 是一个泛型参数，而 <code>: usize</code> 则表明
<code>N</code> 的类型是 <code>usize</code> 。这段代码定义了一个泛型的 <code>struct</code> ，其中包含一个名为 <code>pos</code> 的数组成员，这个数组元素的类型由 <code>T</code> 决定，而长度由常量泛型参数 <code>N</code> 决定。注意，这里面的 <code>T</code> 和 <code>N</code> 都是编译期参数，也就是说它们在编译期就已经确定，由于 Rust 是一门静态语言，所有变量的类型在编译成机器码时都是可以被推导出来的，
我们不能用一个程序运行期的变量（比如一个用户输入的值）作为 <code>T</code> 或 <code>N</code> ，这是不被允许，并且编译器也无法做到的。</p><p>那么 Rust 为什么要添加 <code>const generics</code> 这个特性呢？其中的原因在 <a href=https://rust-lang.github.io/rfcs/2000-const-generics.html>RFC#2000</a> 已经写得很清楚了，简单来说就是
Rust 将 <code>[T; 1]</code> 、 <code>[T; 2]</code> 、 <code>[T;3]</code> ……这样不同长度的数组看做不同的类型，那么在实现一些操作时就会显得很脏，比如<a href=https://doc.rust-lang.org/1.37.0/std/primitive.array.html#impl-Eq>早期版本的 Rust 标准库</a>在实现比较两个定长数组是否相等的特质 <code>Eq</code> 时就分别对 <code>[T; 0]</code> 、 <code>[T; 1]</code> 、
<code>[T; 2]</code> 等等的定长数组各自实现，一直到 <code>[T; 32]</code> 。那么如果你有一个长度大于 32 的定长数组需要比较时怎么办？
比如这样的代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// https://godbolt.org/z/zn1TYfaev
</span><span class=c1></span><span class=k>fn</span> <span class=nf>compare</span><span class=p>(</span><span class=n>lhs</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>i32</span><span class=p>;</span><span class=w> </span><span class=mi>33</span><span class=p>],</span><span class=w> </span><span class=n>rhs</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>i32</span><span class=p>;</span><span class=w> </span><span class=mi>33</span><span class=p>])</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>lhs</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>rhs</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=c1>// error[E0369]: binary operation `==` cannot be applied to type `&amp;[i32; 33]`
</span><span class=c1>//  --&gt; &lt;source&gt;:2:9
</span><span class=c1>//   |
</span><span class=c1>// 2 |     lhs == rhs
</span><span class=c1>//   |     --- ^^ --- &amp;[i32; 33]
</span><span class=c1>//   |     |
</span><span class=c1>//   |     &amp;[i32; 33]
</span><span class=c1>//   |
</span><span class=c1>//   = note: an implementation of `std::cmp::PartialEq` might be missing for `&amp;[i32; 33]`
</span></code></pre></td></tr></table></div></div><p>编译器会直接报错罢工，而如果把两个 <code>33</code> 全部换成 <code>32</code> 则可以正常编译，是不是感觉非常不可思议？当然这个问题在 2021
年 3 月份 <a href=https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html>const generics 稳定后</a>就已经被解决了。在 Rustc 1.51 以后，你可以对任意长度的 <code>[T; LEN]</code> 运行比较，以及其它相关的操作，再也不用担心编译器摆烂。</p><p>除了解决定长数组的相关问题， const generics 还有其它很多有用的地方，比如可以实现编译期的计算（写 C++
的同学可能已经开始狂喜了，别高兴太早，用 <del>Ruast</del> 的 const generics 来写类似 C++ 的模板元编译期计算会非常地痛苦，
建议不要尝试）等。有一个相对关键的点在于，泛型参数只存在于编译期，也就是说在运行期这个参数不存在。这也意味着常量泛型参数自己并不占内存，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>Foo</span><span class=o>&lt;</span><span class=k>const</span><span class=w> </span><span class=n>N</span>: <span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>value</span>: <span class=kt>i64</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>这个结构体的大小用 <code>std::mem::size_of::&lt;Foo&lt;1>>()</code> 求出来是 <code>8</code> ，正好等于 <code>i64</code> 本身的大小；事实上，不管
<code>N</code> 取多少，甚至 <code>std::mem::size_of::&lt;Foo&lt;114514>>()</code> ，得到的仍然是 <code>8</code> ，这为编译器的优化提供了可能。</p><p>除此之外，当 <code>N</code> 不同时， <code>Foo&lt;N></code> 被认为是不同的类型。即使你分别为 <code>Foo&lt;N1></code> 和 <code>Foo&lt;N2></code> 分别实现了相同的特质（这里以 <code>Eq</code> 为例），那么当你写下 <code>Foo::&lt;N1>::default() == Foo::&lt;N2>::default()</code> 这样的代码时，除非 <code>N1 == N2</code>
否则编译器会报错提醒你：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Default, PartialEq, Eq)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Foo</span><span class=o>&lt;</span><span class=k>const</span><span class=w> </span><span class=n>N</span>: <span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>value</span>: <span class=kt>i64</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Foo</span>::<span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span>::<span class=n>default</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>Foo</span>::<span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;</span>::<span class=n>default</span><span class=p>());</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=c1>// error[E0308]: mismatched types
</span><span class=c1>//  --&gt; src/main.rs:7:43
</span><span class=c1>//   |
</span><span class=c1>// 7 |     println!(&#34;{}&#34;, Foo::&lt;0&gt;::default() == Foo::&lt;1&gt;::default());
</span><span class=c1>//   |                                           ^^^^^^^^^^^^^^^^^^^ expected `0`, found `1`
</span><span class=c1>//   |
</span><span class=c1>//   = note: expected struct `Foo&lt;0&gt;`
</span><span class=c1>//              found struct `Foo&lt;1&gt;`
</span></code></pre></td></tr></table></div></div><p>这个特性对于实现编译期量纲分析是至关重要的，可以说如果没有这个特性，编译期的量纲分析就无法实现。</p><p>当然，现在稳定版的 const generics 所支持的功能还十分有限，如果想了解关于它的更多信息，可以戳<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_2/lang.html?highlight=const%20generics#%E5%85%B3%E4%BA%8E-const-generics-mvp-%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84">这个链接</a>。</p><h2 id=如何使用-const-generics-实现量纲分析>如何使用 Const Generics 实现量纲分析</h2><p>在阐述如何使用 const generics 实现编译期量纲分析之前，我们先来了解一下运行期量纲分析有啥缺点。</p><h3 id=运行期量纲分析>运行期量纲分析</h3><p>为了描述量纲，我们需要定义一个结构体来储存七个基本量纲的指数，为了方便实现，这里直接取国际单位制：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Default, PartialEq, Eq, Clone, Copy)]</span><span class=w>   </span><span class=c1>// make SiUnit::default() and SiUnit == SiUnit possible
</span><span class=c1></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>      </span><span class=n>m</span>: <span class=kt>i8</span><span class=p>,</span><span class=w>    </span><span class=c1>// meter
</span><span class=c1></span><span class=w>      </span><span class=n>s</span>: <span class=kt>i8</span><span class=p>,</span><span class=w>    </span><span class=c1>// second
</span><span class=c1></span><span class=w>     </span><span class=n>kg</span>: <span class=kt>i8</span><span class=p>,</span><span class=w>    </span><span class=c1>// kilogram
</span><span class=c1></span><span class=w>      </span><span class=n>c</span>: <span class=kt>i8</span><span class=p>,</span><span class=w>    </span><span class=c1>// coulomb
</span><span class=c1></span><span class=w>     </span><span class=n>cd</span>: <span class=kt>i8</span><span class=p>,</span><span class=w>    </span><span class=c1>// candela
</span><span class=c1></span><span class=w>    </span><span class=n>mol</span>: <span class=kt>i8</span><span class=p>,</span><span class=w>    </span><span class=c1>// mole
</span><span class=c1></span><span class=w>      </span><span class=n>k</span>: <span class=kt>i8</span><span class=p>,</span><span class=w>    </span><span class=c1>// kelvin
</span><span class=c1></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>SiUnit</span>::<span class=n>default</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>然后这个结构体需要实现加减运算特质，以满足两个物理量乘除时对量纲的运算：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=p>{</span><span class=n>Add</span><span class=p>,</span><span class=w> </span><span class=n>Sub</span><span class=p>,</span><span class=w> </span><span class=n>Mul</span><span class=p>,</span><span class=w> </span><span class=n>Div</span><span class=p>};</span><span class=w>   </span><span class=c1>// required trait for overload of `+` and `-`.
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Add</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Self</span><span class=p>;</span><span class=w>     </span><span class=c1>// required associate type
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>              </span><span class=n>m</span>: <span class=nc>self</span><span class=p>.</span><span class=n>m</span><span class=w>    </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>m</span><span class=p>,</span><span class=w>
</span><span class=w>              </span><span class=n>s</span>: <span class=nc>self</span><span class=p>.</span><span class=n>s</span><span class=w>    </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>s</span><span class=p>,</span><span class=w>
</span><span class=w>             </span><span class=n>kg</span>: <span class=nc>self</span><span class=p>.</span><span class=n>kg</span><span class=w>   </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>kg</span><span class=p>,</span><span class=w>
</span><span class=w>              </span><span class=n>c</span>: <span class=nc>self</span><span class=p>.</span><span class=n>c</span><span class=w>    </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>c</span><span class=p>,</span><span class=w>
</span><span class=w>             </span><span class=n>cd</span>: <span class=nc>self</span><span class=p>.</span><span class=n>cd</span><span class=w>   </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>cd</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>mol</span>: <span class=nc>self</span><span class=p>.</span><span class=n>mol</span><span class=w>  </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>mol</span><span class=p>,</span><span class=w>
</span><span class=w>              </span><span class=n>k</span>: <span class=nc>self</span><span class=p>.</span><span class=n>k</span><span class=w>    </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>k</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Sub</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Self</span><span class=p>;</span><span class=w>     </span><span class=c1>// required associate type
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>sub</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=p>...</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>这样我们就可以直接执行 <code>SiUnit + SiUnit</code> 、 <code>SiUnit - SiUnit</code> 这样的操作了。</p><p>为了实现物理量的乘方开方运算，它还需要实现 <code>Mul</code> 和 <code>Div</code> 特质，与实现 <code>Add</code>
和 <code>Sub</code> 特质不同的是， <code>Mul</code> 和 <code>Div</code> 特质里的右操作数 <code>Rhs</code> 都是 <code>i8</code>
类型，而不是 <code>SiUnit</code> 本身，因为乘方开方的指数都是没有量纲的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=p>{</span><span class=n>Mul</span><span class=p>,</span><span class=w> </span><span class=n>Div</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Mul</span><span class=o>&lt;</span><span class=kt>i8</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Self</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>mul</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=kt>i8</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>              </span><span class=n>m</span>: <span class=nc>self</span><span class=p>.</span><span class=n>m</span><span class=w>    </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>              </span><span class=n>s</span>: <span class=nc>self</span><span class=p>.</span><span class=n>s</span><span class=w>    </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>             </span><span class=n>kg</span>: <span class=nc>self</span><span class=p>.</span><span class=n>kg</span><span class=w>   </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>              </span><span class=n>c</span>: <span class=nc>self</span><span class=p>.</span><span class=n>c</span><span class=w>    </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>             </span><span class=n>cd</span>: <span class=nc>self</span><span class=p>.</span><span class=n>cd</span><span class=w>   </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>mol</span>: <span class=nc>self</span><span class=p>.</span><span class=n>mol</span><span class=w>  </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>              </span><span class=n>k</span>: <span class=nc>self</span><span class=p>.</span><span class=n>k</span><span class=w>    </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Div</span><span class=o>&lt;</span><span class=kt>i8</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Self</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>div</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=kt>i8</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=p>...</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>此时， <code>SiUnit</code> 可以进行 <code>SiUnit * 2</code> 、 <code>SiUnit / 2</code> 这样的运算了。那么把和一个值打包在一起就组成一个物理量了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>value</span>: <span class=nc>T</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>unit</span>:  <span class=nc>SiUnit</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>然后我们再为它实现各种运算操作，就可以用它代入各种公式求值了。那么这其中有什么问题呢？</p><ol><li>它占用的内存太多。用 <code>std::mem::size_of::&lt;PhysicalQuantity&lt;f64>>()</code> 查看一下这个结构体占用的内存，
为 16 字节，这说明不参与值运算的 <code>unit</code> 成员就占用了一半的空间；如果对一个 <code>[PhysicalQuantity; len]</code>
这样的数组运算，那么所有元素的 <code>unit</code> 成员就交错分布在真正需要运算的 <code>value</code> 成员中间，这对 CPU
的缓存命中和 SIMD 优化是非常不利的，进而造成可观的性能损失；</li><li><code>PhysicalQuantity</code> 之间没有区分，也就是说 <code>unit</code> 不同的 <code>PhysicalQuantity</code> 被认为是同一个类型，
当它们被放在同一个数组等线性表里时，编译器不会报错，而且人工检查也只能在运行时进行；</li><li><code>PhysicalQuantity</code> 在执行加减运算时需要手动检查 <code>unit</code> 是否一致；在执行乘除法时，需要对 <code>unit</code> 运行相应
的运算，这些均在运行时进行，并且每个元素操作时都要做，这也会严重降低运行效率。</li></ol><p>如此这些缺陷在 const generics 的加持下都可以解决。</p><h3 id=利用-const-generics-实现编译期的量纲分析>利用 const generics 实现编译期的量纲分析</h3><p>为了让编译器在编译期帮助我们推导量纲，我们可以利用 const generics ，把量纲信息放在泛型参数里，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#![feature(adt_const_params)]</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>num</span>::<span class=n>Num</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(PartialEq)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nc>Num</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>value</span>: <span class=nc>T</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=o>&gt;</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nc>Num</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>value</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>需要注意的是，在现在 Rustc 最新稳定版(1.67)里，只能支持整数、 <code>bool</code> 以及 <code>char</code> 作为 const generic params ，
想要放结构体进去需要切换到 nightly 频道，并在代码开头加上 <code>#![feature(adt_const_params)]</code> 来开启 <code>adt_const_params</code>
这个 feature ，从而支持把 <code>SiUnit</code> 放到泛型参数里。此时，运行 <code>std::mem::size_of&lt;PhysicalQuantity&lt;f64, SiUnit::default()>>()</code> ，
输出为 8 ，说明没有多余的空间占用，第一个问题得以解决。</p><p>为了方便起见，我们定义一些类型别名</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>const</span><span class=w> </span><span class=n>METER</span>: <span class=nc>SiUnit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>      </span><span class=n>m</span>: <span class=mi>1</span><span class=p>,</span><span class=w>
</span><span class=w>      </span><span class=n>s</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>     </span><span class=n>kg</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>      </span><span class=n>c</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>     </span><span class=n>cd</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>mol</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>      </span><span class=n>k</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>type</span> <span class=nc>Meter</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>METER</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>const</span><span class=w> </span><span class=n>METER_PER_SEC</span>: <span class=nc>SiUnit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>      </span><span class=n>m</span>:  <span class=mi>1</span><span class=p>,</span><span class=w>
</span><span class=w>      </span><span class=n>s</span>: <span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=w>
</span><span class=w>     </span><span class=n>kg</span>:  <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>      </span><span class=n>c</span>:  <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>     </span><span class=n>cd</span>:  <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>mol</span>:  <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>      </span><span class=n>k</span>:  <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>type</span> <span class=nc>Mps</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>METER_PER_SEC</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>然后比较一个两个量纲不同的量，看会有什么反应</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Meter</span>::<span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>value</span>: <span class=mf>1.0</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Mps</span>::<span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=n>value</span>: <span class=mf>2.0</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=n>assert_ne</span><span class=o>!</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>);</span><span class=w>   </span><span class=c1>// cannot compile
</span><span class=c1>// error[E0308]: mismatched types
</span><span class=c1>//   --&gt; src/main.rs:54:5
</span><span class=c1>//    |
</span><span class=c1>// 54 |     assert_ne!(a, b);   // cannot compile
</span><span class=c1>//    |     ^^^^^^^^^^^^^^^^ expected `SiUnit { m: 1, s: 0, kg: 0, c: 0, cd: 0, mol: 0, k: 0 }`, found `SiUnit { m: 1, s: -1, kg: 0, c: 0, cd: 0, mol: 0, k: 0 }`
</span><span class=c1>//    |
</span><span class=c1>//    = note: expected struct `PhysicalQuantity&lt;_, SiUnit { m: 1, s: 0, kg: 0, c: 0, cd: 0, mol: 0, k: 0 }&gt;`
</span><span class=c1>//               found struct `PhysicalQuantity&lt;_, SiUnit { m: 1, s: -1, kg: 0, c: 0, cd: 0, mol: 0, k: 0 }&gt;`
</span><span class=c1>//    = note: this error originates in the macro `assert_ne` (in Nightly builds, run with -Z macro-backtrace for more info)
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=c1>// For more information about this error, try `rustc --explain E0308`.
</span></code></pre></td></tr></table></div></div><p>此时，编译器拒绝编译，并给出了错误信息，其中明确说明参数 <code>b</code> 存在类型错误，从而避免用户强行将两者放在一起比较。
这也表明只要量纲一致，那么类型肯定一致；反之如果量纲不一致，类型也一定不同，这可以将用户的编码错误提前到编译期暴露出来，
第二个问题得以解决。</p><p>以上只是一个示例，下面我们来为 <code>PhysicalQuantity</code> 实现更多功能。</p><h4 id=siunit-的编译期运算><code>SiUnit</code> 的编译期运算</h4><p>首先，我们需要在编译期对 <code>SiUnit</code> 进行运算，之前的 <code>impl Add for SiUnit { ... }</code> 是为 <code>SiUnit</code> 实现一个函数，
然而这个函数只能在运行期跑，如何解决？这里就要用到 nightly 的另一个不稳定特性 <code>const_trait_impl</code> ，然后
<code>impl const Add for SiUnit</code> 就可以了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#![feature(const_trait_impl)]</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>Add</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>Sub</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>Mul</span><span class=o>&lt;</span><span class=kt>i8</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>Div</span><span class=o>&lt;</span><span class=kt>i8</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><h4 id=physicalquantity-的加减法运算><code>PhysicalQuantity</code> 的加减法运算</h4><p>然后我们来考虑为 <code>PhysicalQuantity</code> 实现各种运算。我们先为它实现最为简单的加减运算，由于加减运算的两个操作数量纲一致，
类型肯定相同，那么实现加减法就不需要对 <code>SiUnit</code> 进行运算：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=o>&gt;</span><span class=w> </span><span class=n>Add</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nc>Num</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>value</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=o>&gt;</span><span class=w> </span><span class=n>Sub</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nc>Num</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>sub</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>value</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><h4 id=physicalquantity-的乘除法运算><code>PhysicalQuantity</code> 的乘除法运算</h4><p>而 <code>PhysicalQuantity</code> 的乘除法不要求左右操作数量纲一致，并且产生的结果可能有着第三种量纲，因此在实现乘除法的特质时会稍微麻烦一点，也会用到本文提到的第三个不稳定特性 <code>generic_const_exprs</code> ，它支持在 const generic params 里写表达式，
而这个表达式则需要用花括号包起来，比如像 <code>PhysicalQuantity&lt;T, {U+V}></code> 这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#![feature(generic_const_exprs)]</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>V</span>: <span class=nc>SiUnit</span><span class=o>&gt;</span><span class=w> </span><span class=n>Mul</span><span class=o>&lt;</span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Num</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>+</span><span class=n>V</span><span class=p>}</span><span class=o>&gt;</span>:<span class=p>,</span><span class=w>    </span><span class=c1>// generic_const_exprs used
</span><span class=c1></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>+</span><span class=n>V</span><span class=p>}</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>mul</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>value</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>V</span>: <span class=nc>SiUnit</span><span class=o>&gt;</span><span class=w> </span><span class=n>Div</span><span class=o>&lt;</span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Num</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>-</span><span class=n>V</span><span class=p>}</span><span class=o>&gt;</span>:<span class=p>,</span><span class=w>    </span><span class=c1>// generic_const_exprs used
</span><span class=c1></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>-</span><span class=n>V</span><span class=p>}</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>div</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>value</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>上面的代码的每个特质的实现中，除了 <code>T</code> 之外，一共有三个泛型，分别是 <code>U</code> 、 <code>V</code> 和 <code>U±V</code> ，而在 <code>impl&lt;></code> 只能写 <code>U</code> 和 <code>V</code>
这两个参数（ <code>U</code> 属于 <code>PhysicalQuantity</code> ， <code>V</code> 存在于 <code>Mul&lt;Rhs></code> 中的 <code>Rhs</code> 内），那么 <code>U±V</code> 就只能放在 <code>where</code> 里进行约束了。</p><p>那么，为什么不直接 <code>where {U±V}:,</code> 这样来约束呢，那是因为现在编译器还不够强，不支持这样写，如果 <code>U</code> 和 <code>V</code> 是 <code>usize</code> 类型，
官方支持 <code>where [(); {U±V}]:,</code> 这样来进行约束。但不幸的是，这里的 <code>U</code> 和 <code>V</code> 是 <code>SiUnit</code> 类型，除非你为它实现了转换到 <code>usize</code>
的特质，然后写 <code>where [(); {U±V}.into::&lt;usize>()]:,</code> 这样的约束条件。除了这个选择，我们可以直接约束 <code>PhysicalQuantity&lt;T, {U±V}></code>
这个类型本身，幸运的是， rustc 确实接受这样的写法，谢天谢地。</p><p>顺便吐槽一下， <code>generic_const_exprs</code> 所支持的表达式十分有限，甚至当 <code>U</code> 和 <code>V</code> 为 <code>usize</code> 时， <code>{U+V}</code> 和 <code>{V+U}</code> 被认为是不等价的，
这也意味着我们在写表达式时需要十分小心表达式的顺序，如果写错的话，编译器吐出来的东西可能会非常难看……</p><p>言归正传，经过上面的实现后，我们可以对不同量纲的物理量进行乘除运算了，比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Meter</span>::<span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>value</span>: <span class=mf>1.0</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Mps</span>::<span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>value</span>: <span class=mf>2.0</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;type: {}, value: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>std</span>::<span class=n>any</span>::<span class=n>type_name_of_val</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=p>),</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>value</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=c1>// type: playground::PhysicalQuantity&lt;f64, playground::SiUnit { m: 0, s: 1, kg: 0, c: 0, cd: 0, mol: 0, k: 0 }&gt;, value: 0.5
</span></code></pre></td></tr></table></div></div><p>在打印出 <code>c</code> 的类型后，它的量纲确实是时间，说明我们的实现是正确的。</p><h4 id=physicalquantity-的乘方开方运算><code>PhysicalQuantity</code> 的乘方开方运算</h4><p>到现在为止，我们已经为 <code>PhysicalQuantity&lt;T, U></code> 实现了四则运算。相比于前面的实现，乘方、开方的运算要更麻烦一些，因为返回值的量纲取决于指数，等于说返回的类型取决于指数，这要求我们必须把指数放在 <code>const generics param</code> 的位置上，否则存在于运行期的指数无论如何也无法让编译器在编译期推导出返回类型。特质 <code>num::pow::Pow</code> 定义了 <code>.pow()</code> 函数，但这个函数的签名中指数存在于第二个函数参数的位置上，而不是常量泛型参数的位置上，因此不能使用；尽管如此，我们仍可以照猫画虎，仿照 <code>num::pow::Pow</code>
来自己定义一个特质 <code>Power</code> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>PowerI</span><span class=o>&lt;</span><span class=k>const</span><span class=w> </span><span class=n>power</span>: <span class=kt>i8</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=p>;</span><span class=w>    </span><span class=c1>// 关联类型
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>powi</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>然后为 <code>PhysicalQuantity</code> 实现它</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>power</span>: <span class=kt>i8</span><span class=o>&gt;</span><span class=w> </span><span class=n>PowerI</span><span class=o>&lt;</span><span class=n>power</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Num</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Pow</span><span class=o>&lt;</span><span class=kt>i8</span><span class=p>,</span><span class=w> </span><span class=n>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>*</span><span class=n>power</span><span class=p>}</span><span class=o>&gt;</span>:<span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>*</span><span class=n>power</span><span class=p>}</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>powi</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=n>power</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>最后，我们应该怎样调用它呢？经过与 rustc 的搏斗，我发现主要有以下两种写法：</p><ol><li><code>let f2 = &lt;Meter&lt;f64> as PowerI&lt;2>>::powi(f);</code></li><li><code>let f2 = PowerI::&lt;2>::powi(f);</code></li></ol><p>第 1 种写法看着就令人头疼，第 2 种写法稍微好一些，但也只是五十步笑百步。造成写法如此难看的原因是指数 <code>power</code>
被放在了 <code>trait</code> 的泛型参数里，而不是 <code>fn powi&lt;power>(self) ...</code> 这个函数的泛型参数里。但是，如果将 <code>power</code>
写在 <code>fn powi()</code> 里，那么当你在实现时不得不面对 <a href=https://doc.rust-lang.org/error_codes/E0207.html>E0207 错误</a> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>PowerI</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>powi</span><span class=o>&lt;</span><span class=k>const</span><span class=w> </span><span class=n>power</span>: <span class=kt>i8</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>power</span>: <span class=kt>i8</span><span class=o>&gt;</span><span class=w> </span><span class=n>PowerI</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Num</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Pow</span><span class=o>&lt;</span><span class=kt>i8</span><span class=p>,</span><span class=w> </span><span class=n>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>*</span><span class=n>power</span><span class=p>}</span><span class=o>&gt;</span>:<span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>*</span><span class=n>power</span><span class=p>}</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>powi</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w>
</span><span class=w>    </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=n>power</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=c1>//     |
</span><span class=c1>// 182 | impl&lt;T, const U: SiUnit, const power: i8&gt; PowerI for PhysicalQuantity&lt;T, U&gt;
</span><span class=c1>//     |                          ^^^^^^^^^^^^^^^ unconstrained const parameter
</span><span class=c1>//     |
</span><span class=c1>//     = note: expressions using a const parameter must map each value to a distinct output value
</span><span class=c1>//     = note: proving the result of expressions other than the parameter are unique is not supported
</span></code></pre></td></tr></table></div></div><p>这个报错告诉我们常量泛型参数 <code>power</code> 必须出现在 <code>impl&lt;...> Trait&lt;...> for Object&lt;...></code> 的后两个尖括号内，
或者直接出现 <code>where</code> 约束的从句里，以表达式的形式出现则不被接受。上面代码里就是因为
<code>where PhysicalQuantity&lt;T, {U*power}></code> 中 <code>power</code> 是以表达式的形式出现而被拒绝编译，以笔者水平，看来这条路是走不通了。</p><p>那有没有简单、直接点的实现，让我们可以 <code>f.powi::&lt;power>()</code> 呢？当然有的，直接 <code>impl</code> ，给 <code>PhysicalQuantity</code>
添加方法即可：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=o>&gt;</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Num</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Pow</span><span class=o>&lt;</span><span class=kt>i8</span><span class=p>,</span><span class=w> </span><span class=n>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>powi</span><span class=o>&lt;</span><span class=k>const</span><span class=w> </span><span class=n>power</span>: <span class=kt>i8</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>*</span><span class=n>power</span><span class=p>}</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>PhysicalQuantity</span>::<span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>*</span><span class=n>power</span><span class=p>}</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=n>power</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>这样就能使用 <code>let f2 = f.powi::&lt;2>()</code> 来求得 <code>f</code> 的平方了，看起来这样的实现既简单，效果也好 <del>所谓大道至简，也即是如此吧2333</del> 。
至于开方，它和乘方的实现几乎一致，这里限制 <code>T</code> 为浮点数类型，为了使返回类型 <code>T</code> 与输入类型 <code>T</code> 一致：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>U</span>: <span class=nc>SiUnit</span><span class=o>&gt;</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Float</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>From</span><span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>nth_root</span><span class=o>&lt;</span><span class=k>const</span><span class=w> </span><span class=n>root</span>: <span class=kt>i8</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>/</span><span class=n>root</span><span class=p>}</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>PhysicalQuantity</span>::<span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=n>U</span><span class=o>/</span><span class=n>root</span><span class=p>}</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=p>.</span><span class=n>powf</span><span class=p>((</span><span class=mf>1.0</span><span class=k>f64</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>f64</span><span class=p>).</span><span class=n>into</span><span class=p>())</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>然后就可以 <code>f.nth_root::&lt;3>()</code> 来求 <code>f</code> 的立方根了。</p><h4 id=无量纲数及常系数的特殊处理>无量纲数及常系数的特殊处理</h4><p>有时公式中还会出现无量纲系数直接相乘的情况，比如 \(\frac{1}{4\pi \epsilon}\) ，
这时如果把 \(4\pi\) 手动写成 <code>PhysicalQuantity::&lt;T, U>::new(4.0 * pi)</code> 的形式，未免过于冗长。这种情况下，我们需要为直接数
<code>T</code> 实现到无量纲 <code>PhysicalQuantity</code> 类型的转换特质：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>const</span><span class=w> </span><span class=n>DIMENSIONLESS</span>: <span class=nc>SiUnit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SiUnit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>      </span><span class=n>m</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>      </span><span class=n>s</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>     </span><span class=n>kg</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>      </span><span class=n>c</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>     </span><span class=n>cd</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>mol</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>      </span><span class=n>k</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>type</span> <span class=nc>Dimensionless</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PhysicalQuantity</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>DIMENSIONLESS</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nb>From</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Dimensionless</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nc>Num</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>from</span><span class=p>(</span><span class=n>value</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Dimensionless</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Dimensionless</span>::<span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>然后就可以这样写了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mf>4.0.</span><span class=n>into</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;type: {}, value: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>std</span>::<span class=n>any</span>::<span class=n>type_name_of_val</span><span class=p>(</span><span class=o>&amp;</span><span class=n>d</span><span class=p>),</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>value</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=c1>// type: playground::PhysicalQuantity&lt;f64, playground::SiUnit { m: 0, s: 1, kg: 0, c: 0, cd: 0, mol: 0, k: 0 }&gt;, value: 2
</span></code></pre></td></tr></table></div></div><p>注意，这里还有一个坑， <code>let d = 4.0.into() * c</code> 是无法编译的，因为 <code>a * b</code> 运算具体调用哪个函数首先取决于 <code>a</code> 的类型，编译器会查找左操作数类型与 <code>a</code>
一致的函数，然后在其中查找右操作数类型与 <code>b</code> 一致的函数 <code>mul(type_a, type_b)</code> ，最后调用 <code>mul()</code> 。如果 <code>4.0.into()</code> 写在 <code>*</code> 的左边，由于 <code>4.0.into()</code>
得到并不是一个固定的类型，这个类型取决于上下文，那么查找相应 <code>mul</code> 函数的第一步就无法完成，编译器自然会报错。如何解决呢？我们可以指定 <code>.into()</code>
得到的类型： <code>&lt;f64 as Into&lt;Dimensionless&lt;f64>>>::into(4.0)</code> 或者 <code>Dimensionless::&lt;f64>::from(4.0)</code> ，但这两种写法都太麻烦了，不如直接把 <code>4.0.into()</code>
写在右面，一样可以编译通过。</p><p>尽管如此， <code>4.0.into()</code> 这种写法依然看起来很糟糕，为什么不能直接实现 <code>4.0 * c</code> 这样的写法呢？因为要支持这样的写法意味着我们需要对四则运算分别再实现一遍，
像 <code>impl&lt;T> Op&lt;T> for Dimensionless&lt;T> where T: Num</code> 这样；而且由于孤儿规则的存在，编译器也不允许我们
<code>impl&lt;T> Op&lt;Dimensionless&lt;T>> for T where T: Num</code> ，所以只能作罢。出于复用 <code>PhysicalQuantity</code> 之间已经实现的运算的目的，不如把无量纲系数转换为
<code>Dimensionless&lt;T></code> ，再利用已有的函数去实现各种运算，何乐而不为呢（）。至于 <code>4.0.into()</code> 这种看起来很丑的写法，这是 Ruast 的一大特色，不得不品尝，
连标准库的文档里都充斥着 <code>1.0_f64.sqrt()</code> 这种一样“很丑”的写法，习惯就好啦，你多看几眼就不觉得丑啦 <del>（这就是 Ruast 带给我们的自信）</del> 。</p><p>对于一般的数，乘法运算是对易的，但除法却不是。当除数是无量纲数时，我们可以使用 <code>c / 4.0.into()</code> ；但当被除数是无量纲数时，我们只能
<code>Dimensionless::from(4.0f64) / c</code> 这样来处理了。</p><p>对于 \(e^{c}\) 和 \(\ln{c}\) 等限制输入为无量纲数的函数，我们可以通过只为 <code>Dimensionless</code> 类型实现相关函数来实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Dimensionless</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nc>Float</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>exp</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=p>.</span><span class=n>exp</span><span class=p>()</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>ln</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>value</span>: <span class=nc>self</span><span class=p>.</span><span class=n>value</span><span class=p>.</span><span class=n>ln</span><span class=p>()</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>这样，即使用户传入了一个非无量纲数，编译器也会在编译期把这种代码拒之门外。</p><p>至此，我们已经为 <code>PhysicalQuantity</code> 实现了基础的运算操作，现在已经可以用它去做一些简单的推导了，并且推导的过程完全是编译期完成的，
并且只要能编译成功，就能保证结果的量纲和单位正确。</p><h4 id=其它实现>其它实现</h4><p>其实很早就有编译期量纲分析的实现了，它们没有用到 <code>const generics</code> 这个特性，而是直接使用 <a href=https://docs.rs/typenum/latest/typenum/>typenum</a> 这个库提供的 <code>Integer</code> 特质，其定义如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Integer</span>: <span class=nc>Sealed</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Copy</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Default</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>const</span><span class=w> </span><span class=n>I8</span>: <span class=kt>i8</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>const</span><span class=w> </span><span class=n>I16</span>: <span class=kt>i16</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>const</span><span class=w> </span><span class=n>I32</span>: <span class=kt>i32</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>const</span><span class=w> </span><span class=n>I64</span>: <span class=kt>i64</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>const</span><span class=w> </span><span class=n>ISIZE</span>: <span class=kt>isize</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>to_i8</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kt>i8</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>to_i16</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kt>i16</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>to_i32</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>to_i64</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kt>i64</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>to_isize</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kt>isize</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>这个特质作为泛型约束出现，那么它所约束的泛型参数就相当于本文实现中 <code>const unit: SiUnit</code> 内的的成员，然后分别定义了一系列 <code>P1</code> 、 <code>P2</code> 、 <code>N1</code> ……
等等 <strong>类型</strong> ，对这些类型实现 <code>Integer</code> 特质，使用时调用 <code>.to_i8()</code> 等函数则返回 <code>1</code> 、 <code>2</code> 、 <code>-1</code> 等等整数，从而模拟 <code>const generics</code>
内的整数，由于 <code>P1</code> 等本质还是类型，所以它不受 <code>const generics</code> 里弱鸡表达式的限制，当然作者为了实现类型之间的运算也是花了很大的功夫，
这里就不谈了（其实是没读懂）。比较完善的量纲分析库，我找到的有两个，分别是 <a href=https://docs.rs/dimensioned/latest/dimensioned/>dimensioned</a> 和 <a href=https://docs.rs/uom/latest/uom/>uom</a> ，其中 dimensioned 的作者也是
<code>typenum</code> 的作者， crates.io 上统计 <code>typenum</code> 的下载量将近八千万，而 <code>dimensioned</code> 也就三万不到，对于作者来说
<code>dimensioned</code> 只是顺手一写的小项目了，即便如此，它的提供了丰富的内置单位和转换操作，足够一般使用。</p><p>除了使用 <code>typenum</code> 库的实现，还有用 <code>const generics</code> 实现的库 <a href=https://docs.rs/const_unit_poc/latest/const_unit_poc/>const_unit_poc</a> ，这是利用 const generics 实现量纲分析的一个
proof of concept ，足够简短，代码也好读，本文就是参考了它的实现。</p><h2 id=总结>总结</h2><p>本文分别实现了运行期的量纲分析和借助 const genreics 实现的编译期量纲分析，着重后者了后者的优势，以及实现上的细节。在使用 const generics
时，依次用到了三个不稳定特性： <code>adt_const_params</code> （让 const generics 支持自定义的 <code>SiUnit</code> 结构体）， <code>const_trait_impl</code> （为 <code>SiUnit</code>
实现编译期的四则运算）和 <code>generic_const_exprs</code> （允许在 const generic params 内写表达式）。这些不稳定特性现在只能临时使用，将来可能会有语法、
行为上的变化，因此本文的实现不保证在未来依然可用。在实现的同时，我们也发现了一些 Rust 不那么优雅的地方，比如冗长的
<code>&lt;f64 as Into&lt;Dimensionless&lt;f64>>>::into(4.0)</code> 表达式、对孤儿规则的妥协、 <code>generic_const_exprs</code> 对表达式极为有限的支持等等。
不过相比起 C++ 标准的更新速度， Rust 的标准库更新速度还是可以期待的。</p><p>本文实现的全部代码在<a href="https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=4807be24f1e6493bcc5c7cb86457439c">这里</a><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</p><p>还有几篇博文对本人帮助很大：</p><ol><li>zqp-cn 大佬的<a href=https://zjp-cn.github.io/rust-note/forum/impl-const-param.html>针对常量泛型参数的分类实现</a>；</li><li>Rust 官方的 <a href=https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html>Const generics MVP hits beta!</a>；</li><li>Rust 官方的 <a href=https://blog.rust-lang.org/inside-rust/2021/09/06/Splitting-const-generics.html>Splitting the const generics features</a>；</li><li>Rust 中文社区 2021 年的<a href=https://rustmagazine.github.io/rust_magazine_2021/chapter_11/bench-and-const.html>Rust AEAD benchmark 与 Const generics</a>。</li></ol><p>说来编译期的量纲分析其实在 1995 年就被 John J. Barton 和
Lee R. Nackman<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>
使用 C++ 的模板元编程所实现，
C++ 大师 Scott Meyers 也曾专门写了一篇文章阐述如何使用 C++ template 实现量纲分析<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> 。
本人其实也是受这个实现所启发，进而产生了用 Rust 的泛型系统重新实现一下这个功能的想法，进而稍微读了些前人的实现，之后便有了这篇文章。
不得不感叹，读别人的代码和自己写完全是两种感觉，有些坑只有自己踩了才会知道，也才能明白有些代码写得拐弯抹角是为了解决啥问题，有啥优势等等。</p><p>超长假期学到的一点点东西总算记录了下来，希望不会那么快地忘掉。现在已经开学一两周了，接下来的一两年可能才是艰难险阻的开始，祈祷好运吧……</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Dimensional_analysis>https://en.wikipedia.org/wiki/Dimensional_analysis</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html>https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href="https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=4807be24f1e6493bcc5c7cb86457439c">https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=4807be24f1e6493bcc5c7cb86457439c</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Scott Meyers 的文章
<a href=https://se.inf.ethz.ch/~meyer/publications/OTHERS/scott_meyers/dimensions.pdf>https://se.inf.ethz.ch/~meyer/publications/OTHERS/scott_meyers/dimensions.pdf</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>Ionizing</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2023-03-05</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=http://ionizing.page/tags/posts/>Posts</a>
<a href=http://ionizing.page/tags/rust/>Rust</a>
<a href=http://ionizing.page/tags/constgenerics/>ConstGenerics</a></div><nav class=post-nav><a class=next href=/post/simple-dft-toy/><span class="next-text nav-default">简易 DFT 玩具</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=icon-links><a href=mailto:petersmith_9@outlook.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg></a><a href=http://github.com/Ionizing rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg></a><a href=http://ionizing.page/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a></span>
<span class=copyright-year>&copy;
2021 -
2023
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg></i></span><span class=author>Ionizing</span></span></div></footer><div class=back-to-top id=back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script><script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script><script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type=text/javascript src=/js/load-photoswipe.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>