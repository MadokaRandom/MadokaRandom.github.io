:CONFIG:
#+HUGO_BASE_DIR: ../
#+HUGO_FRONT_MATTER_FORMAT: yaml
#+SETQ_TODO: TODO DRAFT DONE
#+PROPERTY: header-args :eval never-export
#+OPTIONS: toc:3 author:nil
:END:


* Table of Contents    :TOC_2:
- [[#about][About]]
- [[#external-link][External-link]]
- [[#posts][Posts]]
  - [[#新的旅程][新的旅程]]
  - [[#记一次-julia-代码性能优化过程][记一次 Julia 代码性能优化过程]]
  - [[#vasp-收敛性测试的小脚本][VASP 收敛性测试的小脚本]]
  - [[#vasp-偶极校正及功函数的计算][VASP 偶极校正及功函数的计算]]
  - [[#组内集群折腾实录][组内集群折腾实录]]
  - [[#镜像态的那些坑][镜像态的那些坑]]
  - [[#rsgrad-开发收获][Rsgrad 开发收获]]
  - [[#haskell-学习笔记][Haskell 学习笔记]]

* DONE About :about:
CLOSED: [2021-4-13 Tue]
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_HUGO_SECTION: ./
:EXPORT_HUGO_MENU: :menu main
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :weight 50
:EXPORT_DATE: [2021-04-13]
:END:

A Ph.D candidate who majors in physical chemistry.

| Abilities | Level[fn:1] |
|-----------+-------------|
| C/C++     | Beginner    |
| Rust      | Beginner    |
| LaTeX     | Newbie      |
| VASP      | Beginner    |
| Linux     | Beginner    |

[fn:1] https://english.stackexchange.com/questions/83832/list-of-expertise-levels-from-beginner-to-expert


* DONE External-link
CLOSED: [2021-04-16 Fri 21:26]
:PROPERTIES:
:EXPORT_FILE_NAME: external-link
:EXPORT_HUGO_SECTION: ./
:EXPORT_HUGO_MENU: :menu main
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :weight 60
:EXPORT_DATE: [2021-04-16]
:END:

|-----------+-----------------------------------|
| Person    | Link                              |
|-----------+-----------------------------------|
| Liam0205  | https://liam.page/about/          |
| Mr. Joker | https://mrjokersince1997.gitee.io |
|-----------+-----------------------------------|


* Posts                :Posts:
:PROPERTIES:
:EXPORT_HUGO_SECTION: post
:END:

** DONE 新的旅程 :@杂项:回归:模板:配置:
CLOSED: [2021-04-14 Wed 16:15]
:PROPERTIES:
:EXPORT_FILE_NAME: a-new-journey
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :katex true :markup goldmark
:END:

这是回归博客写作后的第一篇文章

#+hugo: more

*** 回归
时光荏冉，已经好久没有更新博客了，上一次写博客还是去年寒假疫情在家时期。

这一年多以来总算把与实验组合作的几个工作结束了（第一次实践使用 VASP ），这几个工
作感觉能总结的地方不多，都是细节居多，但坑还是不少的。我自己的工作做了快两年了
（看来平时没少摸鱼），在去年底它的进度有了 180 度转变，这还多亏了导师的嘱托，让
我在补充图表时 Review 了一下之后的结果，一看就发现之前的结论完全错误，于是重新跑
了一下 NAMD ，这次的结果终于符合「预期」了，但现在似乎又遇到了一些不大不小的问题，
即能带交叉的处理，目测解决它又要费些时间了（而且还中间还有其它实验组的东西要做）。

说了这段时间自己在做什么，下面就该讲博客相关的东西了。

*** 博客相关
关于博客，我这次决心将它迁移到 Hugo 框架下，配合 Org-mode 和 ox-hugo 使用，至少
到现在体验挺好：
- Hugo 很快，生成静态页面耗时在 ms 量级，比 Hexo 不知道高到哪里去了；
- Org-mode 很强大，谁用谁知道；
- 私以为 Jane 主题足够简约，也留了足够的空间折腾。

近期做了些工作，我会把心得总结起来放到博客上，供自己和小伙伴们参考～

**** 配置、模板
以下是写博客时可能要用到的一些模板/配置，仅供自己参考了。

- Org-mode 中 CJK 文档的 soft space 问题，已经有人给出了解决方案[fn:: http://zwz.github.io] ：
#+begin_src elisp
(defun clear-single-linebreak-in-cjk-string (string)
"clear single line-break between cjk characters that is usually soft line-breaks"
(let* ((regexp "\\([\u4E00-\u9FA5]\\)\n\\([\u4E00-\u9FA5]\\)")
        (start (string-match regexp string)))
    (while start
    (setq string (replace-match "\\1\\2" nil nil string)
            start (string-match regexp string start))))
string)

(defun ox-html-clear-single-linebreak-for-cjk (string backend info)
(when (org-export-derived-backend-p backend 'html)
    (clear-single-linebreak-in-cjk-string string)))

(eval-after-load "ox"
  '(add-to-list 'org-export-filter-final-output-functions
                'ox-html-clear-single-linebreak-for-cjk))
#+end_src
- 添加链接时使用 src_elisp[:exports code]{C-c C-l} ， Doom-Emacs 会提示你输入链
   接的 URL 和 description；
- 使用 Inline code 时，参考它[fn:: https://stackoverflow.com/questions/16186843/inline-code-in-org-mode/16193498#16193498]： =src_sh[:exports code]{echo -e "test"}= ；
- =:PROPERTIES:= 中 =:@cat:= 定义了一个 category =cat= ， =:foo:= 定义了一个 tag =foo= ，
  =:@cat:foo:bar:= 则分别定义了一个 category =cat= ，两个 tags =foo= 、 =bar= ；
- 每篇文章标题前使用 =S-left= 或 =S-right= 可以切换 =TODO= 和 =DONE= 的状态；输
  入数学公式时，需要在 subtree 的 =:PROPERTIES:= 里加上
  =:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :katex true :markup goldmark= 。

   此时 =\(F=ma\)= 表示 inline equation ，输出 \(F=ma\) ； =\[F=ma\]= 表示
  displaystyle equation 。（冷知识[fn::
  https://orgmode.org/worg/org-tutorials/org-latex-preview.html]： Orgmode 支持
  即时渲染公式： =C-c C-x C-l= 会把当前公式渲染好并以 png 的形式插入当前窗口，重
  复这个操作可以关闭预览）

   现在试试一个稍稍复杂点的公式：

\[ \begin{aligned} \nabla \times \vec{\mathbf{B}} - \frac1c
\frac{\partial\vec{\mathbf{E}}}{\partial t} & = \frac{4\pi}{c}\vec{\mathbf{j}}
\newline \nabla \cdot \vec{\mathbf{E}} & = 4 \pi \rho \newline \nabla \times
\vec{\mathbf{E}} + \frac1c \frac{\partial\vec{\mathbf{B}}}{\partial t} & =
\vec{\mathbf{0}} \newline \nabla \cdot \vec{\mathbf{B}} & = 0 \end{aligned} \]

- 使用脚注来代替文献的上标[fn:: https://orgmode.org/manual/Creating-Footnotes.html]
  ，有三种方式：
  1. 声明和定义分离的脚注：在要添加脚注的地方声明 =[fn:NAME]= ，然后在其它地方定
     义这个脚注 =[fn:NAME] some description here ...= ；
  2. 行内定义的脚注：直接使用 =[fn:: some description here ... ]= ，这种方法不需要命名，可谓对程序员十分友好了 23333 ；
  3. 带名字的行内脚注： =[fn:NAME: some description here ...]= 。

**** 图片等外部文件的引用
这一节单独列出来是因为它比数学公式还要难处理，根据 =ox-hugo=[fn:: https://ox-hugo.scripter.co] 的说明，现在有三种引用图片的方法：

1. 使用相对路径：直接把图片放到 =<HUGO_BASE_DIR>/static/= 里，然后引用时可以省略
   =<HUGO_BASE_DIR>/static/= 前缀，例如有一个文件路径是
   =<HUGO_BASE_DIR>/static/image/foo.png= ，引用它时可以这样写：
   =[[image/foo.png]]= ；
2. 使用绝对路径：例如有一个路径是 =~/some/path/foo.png= ，引用它时可以使用
   =[[~/some/path/foo.png]]= ，此时不光在 orgmode 里可以直接预览图片， =ox-hugo=
   在导出时还会把它复制到 =<HUGO_BASE_DIR>/static/ox-hugo/= 里并生成链接；
3. 使用图床：现在 GitHub ， GitLab 等也可以用作图床，并且有成熟的软件来做这件事
   比如 PicGo[fn:: https://github.com/Molunerfinn/PicGo] 。把图片传给图床后，图
   床会返回一个链接，直接把它贴在 orgmode 里就能实现引用图片的效果。但之前我用七
   牛云的图床一段时间后七牛云直接拒绝被薅，改了域名，我也就对图床产生一些顾虑
   +，而且使用图床后一个缺点是，它降低了每篇文章的内聚度，增加了对外部的耦合（掉个
   书袋233）+ 。

因此我还是决定把图片等外部文件放在 =<HUGO_BASE_DIR>/content-org/= 里，每篇文章单
独建一个文件夹，然后使用相对路径引用。下面是效果展示（它使用了
=[[./a-new-journey/himehina.jpeg]]= ）：[[./a-new-journey/himehina.jpeg]]

**** 使用 TikZ 配合 Orgmode 进行画图 [2021-04-29] 更新
Orgmode 原生支持内嵌 \(\LaTeX\) 代码，自然也支持用 TikZ 画图。不过如果想要在利用
TikZ 的输出嵌入到博客中，还需要一点工作要做。
***** 输出 PNG 格式的图片
- 确保机器上已经安装了 ImageMagick 和 \(\LaTeX\) ；
- 在 config 中加入 =(setq org-latex-create-formula-image-program 'imagemagick)= ；

接下来就可以愉快玩耍了：

#+begin_src org
,#+header: :headers '("\\usepackage{tikz}")
,#+header: :results file graphics :file ./a-new-journey/test.png
,#+header: :exports results
,#+header: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
,#+begin_src latex
\begin{tikzpicture}
\draw[->] (-3,0) -- (-2,0) arc[radius=0.5cm,start angle=-180,end angle=0]
    (-1,0) -- (1,0) arc[radius=0.5cm,start angle=180,end angle=0] (2,0) -- (3,0);
\filldraw (-1.5,0) circle[radius=1mm];
\filldraw (1.5,0) circle[radius=1mm];
\end{tikzpicture}
,#+end_src

,#+RESULTS:
[[file:./a-new-journey/test.png]]
#+end_src

Eval 这个 source block 后即可得到：

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./a-new-journey/test.png
#+header: :exports results :imagemagick yes
#+header: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
#+begin_src latex
\begin{tikzpicture}
\draw[->] (-3,0) -- (-2,0) arc[radius=0.5cm,start angle=-180,end angle=0]
    (-1,0) -- (1,0) arc[radius=0.5cm,start angle=180,end angle=0] (2,0) -- (3,0);
\filldraw (-1.5,0) circle[radius=1mm];
\filldraw (1.5,0) circle[radius=1mm];
\end{tikzpicture}
#+end_src

#+RESULTS:
[[file:./a-new-journey/test.png]]


***** 输出 SVG 格式的图片
- 确保机器上已经安装了 \(\LaTeX\)

接下来的工作不那么优雅，我们需要修改一下 =ob-latex.el= 。

因为在 Orgmode 中 Eval 代码块时 Orgmode 会自动把代码块的内容加入预告写好的
Preamble 里生成一个临时文件，但当使用 =.svg= 结尾的输出文件名时它的 Preamble 是
这样的：

#+begin_src latex :exports code
\documentclass[preview]{standalone}
\def\pgfsysdriver{pgfsys-tex4ht.def}
%% Your \usepackage here
\begin{document}
%% Your code here
\end{document}
#+end_src

第二行的 =\def\pgfsysdriver= 需要放在 =\usepackage{tikz}= 后，或者使用 =htlatex=
才能编译，但 ob-latex 使用的是 =latex= ，而且这个过程只会提示 =PDF produced with
errors= ，导致输出的 SVG 是乱码。

查询 =ob-latex.el= 发现，这个 Preamble 是硬编码在 =org-babel-execute:latex= 里的：

#+begin_src elisp :exports code
 (defcustom org-babel-latex-preamble
   (lambda (_)
     "\\documentclass[preview]{standalone}
\\def\\pgfsysdriver{pgfsys-tex4ht.def}
 ")
   "Closure which evaluates at runtime to the LaTeX preamble."

...

          (with-temp-file tex-file
            (insert (concat
                     "\\documentclass[preview]{standalone}
\\def\\pgfsysdriver{pgfsys-tex4ht.def}
 "
                     (mapconcat (lambda (pkg)
                                  (concat "\\usepackage" pkg))
#+end_src

那问题就好办了，直接删掉两处 =\\def\\pgfsysdriver{pgfsys-tex4ht.def}= ，并重新
build （我使用的是 DoomEmacs ，运行 =~/.emacs.d/bin/doom build= ），然后就可以
正常导出了。

#+begin_src org
,#+header: :headers '("\\usepackage{tikz}")
,#+header: :results file graphics :file ./a-new-journey/test.svg
,#+header: :exports results
,#+header: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
,#+begin_src latex
\begin{tikzpicture}
\draw[->] (-3,0) -- (-2,0) arc[radius=0.5cm,start angle=-180,end angle=0]
    (-1,0) -- (1,0) arc[radius=0.5cm,start angle=180,end angle=0] (2,0) -- (3,0);
\filldraw (-1.5,0) circle[radius=1mm];
\filldraw (1.5,0) circle[radius=1mm];
\end{tikzpicture}
,#+end_src

,#+RESULTS:
[[file:./a-new-journey/test.svg]]
#+end_src

输出以下图形：

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./a-new-journey/test.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
#+begin_src latex
\begin{tikzpicture}
\draw[->] (-3,0) -- (-2,0) arc[radius=0.5cm,start angle=-180,end angle=0]
    (-1,0) -- (1,0) arc[radius=0.5cm,start angle=180,end angle=0] (2,0) -- (3,0);
\filldraw (-1.5,0) circle[radius=1mm];
\filldraw (1.5,0) circle[radius=1mm];
\end{tikzpicture}
#+end_src

#+RESULTS:
[[file:./a-new-journey/test.svg]]


其实看 =ob-latex.el= 似乎可以通过用户定义 =org-babel-latex-preamble= 来绕过硬编
码的 Preamble ，但经过测试发现并没有起作用，如果读者有更好方案，请务必联系我。

上面测试用的 TikZ 代码圴来自 Jonny Evans[fn:8]，同时感谢群组内[fn:9]大佬们的帮助。

[fn:8] https://www.homepages.ucl.ac.uk/~ucahjde/blog/tikz.html
[fn:9] https://t.me/emacs_zh

** DONE 记一次 Julia 代码性能优化过程 :@Programming:Julia:Optimization:ParallelProgramming:
CLOSED: [2021-04-16 Fri 13:06]
:PROPERTIES:
:EXPORT_FILE_NAME: a-try-on-julia-code-optimization
:EXPORT_DATE: [2021-04-16]
:END:

这是和某三爷讨论后对交流内容的整理。

#+hugo: more

众所周知， Julia 是一种高级通用动态编程语言，它专为科学计算而生。为了方便科研人
员使用，它的语法被设计得很像 MATLAB ，但比 MATLAB 更合理（譬如数组引用使用 =[]=
，而不是 =()= ）。作为一门很年轻的语言，它吸收了前辈们的很多优点，也有着自己的特
色，但最受人青睐的一点在于：尽管它是一门动态语言，却宣称拥有 C/C++ 一般的性能。
一般而言，动态语言的表现能力更为出色，能用更少的代码做更多的事，开发效率高；而静
态语言的编译器后端更容易优化，运行效率高。Julia 有动态性，开发效率毋庸置疑，一些
测评也显示 Julia 确实拥有很强的性能，但这是否意味着你随手写的一段代码就能有很高
并且达到预期的性能？我看未必。

*** 运行环境

| Processor | Intel Core i5 9600KF |
| Memory    | 16GB 3200MHz         |
| OS        | macOS 10.15.6        |
| Julia     | 1.5.1                |

*** 优化过程
**** 原始版本[fn:1]
废话不多说，直接开始正题，先来看今天的主角[fn:2]
#+begin_src ess-julia :results output :session *julia*
using Rmath;
using BenchmarkTools;

function JGibbs1(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = rgamma(1, 3, 1/(y*y + 4))[1]
            y = rnorm(1, 1/(x+1), 1/sqrt(2(x + 1)))[1]
        end
        mat[i,:] = [x,y]
    end
    mat
end;

@btime JGibbs1(20000, 200);
#+end_src

这是一段关于 Gibbs 采样的代码，它主要由两个循环组成，外部循环一次产生两个值，内
部循环是迭代式的，即下一次循环要用到上次循环的结果。很明显它引入了 R 的库，并用
R 的 =rgamma= 和 =rnorm= 实现，那么它的性能是怎样的呢？

#+RESULTS:
:   501.798 ms (8020002 allocations: 734.56 MiB)

根据原文的说法，它的性能已经比 =Rgibbs= 快 17 倍，比 =RCgibbs= 快 13 倍，已经是
比较令人满意的结果了。

**** 使用 C-ffi 的 =rgamma= 与 =rnorm=[fn:1]

由于直接用 R 写的代码可能并不是最快的，而且它还在内层循环里，所以我们有理由相信
使用 C-ffi[fn:3] 版的 =rgamma= 与 =rnorm= 会更快。

#+begin_src ess-julia :results output :session *julia* :exports both
using Rmath
import Rmath: libRmath
using BenchmarkTools
function JGibbs2(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = ccall((:rgamma, libRmath), Float64, (Float64, Float64), 3., 1/(y*y + 4))
            y = ccall((:rnorm, libRmath), Float64, (Float64, Float64), 1/(x+1), 1/sqrt(2*(x + 1)))
        end
        mat[i,:] = [x,y]
    end
    mat
end

@btime JGibbs2(20000, 200);
#+end_src

#+RESULTS:
: JGibbs2 (generic function with 1 method)
:   259.387 ms (20002 allocations: 2.14 MiB)

果然，使用 C-ffi 版的函数后性能又提升了一倍！

**** 去除外部依赖[fn:1]

尽管使用 C 的实现后， =JGibbs= 性能提升巨大，但依赖外部库多少有点让人感觉不爽，
毕竟它和 Julia 所宣称的高性能关系不是很大（核心部分是 C 的贡献，而不是 Julia）。
既然 Julia 也是高性能语言，何不拿纯 Julia 写一个 =JGibbs= 来比比？

Julia 是为科学计算而生，它的社区维护了一个统计学库 =Distributions= ，里面包含了
=gamma= 与 =norm= 分布的函数，可以用来替换 =rgamma= 和 =rnorm= ，写完之后是这个
样子：

#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

function JGibbs3(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y^2 + 4)), 1)[1]
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))), 1)[1]
        end
        mat[i,:] = [x,y]
    end
    mat
end

@btime JGibbs3(20000, 200);
#+end_src

#+RESULTS:
: JGibbs3 (generic function with 1 method)
:   550.624 ms (8020002 allocations: 734.56 MiB)

咦？看起来它还没有使用 R-ffi 的函数快！

那么问题出在哪呢？仔细看结果，除了时间之外还有两个数据，一个是执行一次该函数时所
分配内存的次数，另一个是函数执行期间分配内存的总量。我们回头看一下使用 C-ffi 的
版本，它的测试结果显示除了性能更强外，内存分配的次数和总量也更少！而且 8020002
恰好是 20002 的 400 倍左右，正好是 =thin=200= 的 2 倍。据此，我们可以猜想，在
=for j=1:thin ... end= 内部存在不必要的内存分配。

下面来进行验证。

**** 内存分配情况分析
取出循环内的一行代码，对它进行 profile ：
#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

@btime rand(Gamma(1.0, 1.0), 1)[1];
#+end_src

#+RESULTS:
:   39.136 ns (1 allocation: 96 bytes)

奇怪，一个只返回一个 Float64 值的函数怎么会存在内存分配？仔细看 =[1]= 这个细节，
问题可能出在这里。通过查看文档，发现 =rand(Gamma(...), 1)= 中最后一个参数表示返
回一个一维的 Array ，并且 Array 的大小是 1 ：
#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

@btime rand(Gamma(1.0, 1.0), 1)
#+end_src

#+RESULTS:
:   37.541 ns (1 allocation: 96 bytes)
: 1-element Array{Float64,1}:
:  0.2929698750637693

一个 Float64 的值有 64 位，共 8 字节（bytes），而刚刚代码中所返回只有一个
Float64 元素的 Array 竟然有 96 字节！既然我们每次只需要返回一个值，那为什么要画
蛇添足去生成一个 Array 呢，直接调用只生成一个值的原型不好吗？

#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

@btime rand(Gamma(1.0, 1.0), 1)
@btime rand(Gamma(1.0, 1.0))
#+end_src

#+RESULTS:
:   37.217 ns (1 allocation: 96 bytes)
: 1-element Array{Float64,1}:
:  0.9938638399122478
:   8.116 ns (0 allocations: 0 bytes)
: 1.8038508272928604

看，直接使用 =rand(Gamma(...))= 耗时只有 =rand(Gamma(...), 1)= 的 22% ，并且内存
的分配是 0 ！

有了这些结论，我们对 =JGibbs3= 修改后，有了下面的代码。

**** 去除内层循环的内存分配
#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

function JGibbs4(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        mat[i,:] = [x,y]
    end
    mat
end

@btime JGibbs4(20000, 200);
#+end_src

#+RESULTS:
: JGibbs4 (generic function with 1 method)
:   251.144 ms (20002 allocations: 2.14 MiB)

这个耗时结果就正常多了，而且比调用 C-ffi 的版本还快了一丢丢；内存的分配也没那么夸张了。

**** 去除外层循环的内存分配

但这并不是它的性能极限：它依然有 20002 次的内存分配。仔细观察外层循环部分，只有
一个 =mat[i,:] = [x,y]= ，通常人们会认为编译器把它循环展开，不涉及内存分配，但事
实并非如此：

#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools

mat = zeros(Int, 2, 2);
@btime mat[1, :] = [1, 2];
@btime mat[:, 1] = [1, 2];
@btime begin
    mat[1, 1] = 1;
    mat[1, 2] = 2;
    end;
@btime begin
    mat[1, 1] = 1;
    mat[2, 1] = 2;
    end;
#+end_src

#+RESULTS:
:   259.485 ns (2 allocations: 112 bytes)
:   220.621 ns (2 allocations: 112 bytes)
:   28.665 ns (0 allocations: 0 bytes)
:   27.603 ns (0 allocations: 0 bytes)

我们可以得出三个结论：
1. 在使用切片赋值时会涉及内存分配，直接使用循环则不会；
2. 小矩阵赋值时使用循环甚至手动展开循环性能更高；
3. Julia 的 Array 使用列主序，对第一个维度操作比对其它维度操作性能更高，但提升幅
   度有限。

于是我们把 =JGibbs4= 中外层循环的矩阵赋值展开，得到 =JGibbs5=

#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

function JGibbs5(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        mat[i,1] = x;
        mat[i,2] = y;
    end
    mat
end

@btime JGibbs5(20000, 200);
#+end_src

#+RESULTS:
: JGibbs5 (generic function with 1 method)
:   229.861 ms (2 allocations: 312.58 KiB)

它比 =JGibbs4= 又快了 20ms ！而且其中内存分配只有两次，已经相当令人满意了。如果
要进一步压榨它的性能潜力，我们可以交换 =mat= 的行列，使外层循环每次赋值时都在访
问第一个维度，限于篇幅原因，这里就不展开了。

**** 使用多线程加速

上面使用的方法都是在一个线程内操作，现在的机器普遍都用上的多核处理器，而超算上更
是单节点上配备了数十个处理器，如此多的计算资源不利用好岂不是暴殄天物。

那么 =JGibbs= 函数能被并行化吗？答案是肯定的。

它的内层循环粒度太小，线程切换的耗时占比太高，因此内层循环不适合并行化。而外层循
环的粒度适中，我们试试将它并行化。

****** 直接使用 =Threads.@threads=

Julia 原生支持多线程编程，并且提供了 =Threads.@threads= 宏来方便对循环并行化，于
是就有了下面的代码
#+begin_src ess-julia :results output :exports both :session *julia*
println("nthreads = ", Threads.nthreads())

using BenchmarkTools;
using Distributions;

function JGibbs6(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    Threads.@threads for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        mat[i,1] = x;
        mat[i,2] = y;
    end
    mat
end

@btime JGibbs6(20000, 200);
#+end_src

#+RESULTS:
: nthreads = 6
: JGibbs6 (generic function with 1 method)
:   420.151 ms (52000035 allocations: 915.84 MiB)
[fn:: 我在启动 =julia= 前对环境变量进行了修改 =export JULIA_NUM_THREADS=6= ，这
样 Julia 在运行时支持最大 6 个线程操作。]

这个结果很离谱。先不谈运行时间，单看它的内存分配量就知道它绝对是有问题的（至于为
什么多出来这么多的内存分配，我也还在寻找原因，如果您有什么见解，请务必发邮件告诉
我 ^_^）， =Julia= 一共开了 6 个线程来加速，但结果显示它反而使运行效率降低了，问
题出在哪呢？仔细看代码

#+begin_src ess-julia
    x   = 0.
    y   = 0.
    Threads.@threads for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        ...
    end
#+end_src

每个线程内，都要对全局变量 =x= 和 =y= 进行修改，并且还要读取它们的值，这显然存在
竞争的现象。那如果把 =x= 和 =y= 移动到每个线程内部定义呢？

#+begin_src ess-julia :results output :session *julia* :exports both
println("nthreads = ", Threads.nthreads())

using BenchmarkTools;
using Distributions;

function JGibbs6_1(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    Threads.@threads for i = 1:N
        x   = rand()
        y   = rand()
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        mat[i,1] = x;
        mat[i,2] = y;
    end
    mat
end

@btime JGibbs6_1(20000, 200);
#+end_src

#+RESULTS:
: nthreads = 6
: JGibbs6_1 (generic function with 1 method)
:   39.926 ms (33 allocations: 316.75 KiB)

这个结果相当令人满意了，内存的分配降低很多，看来读写全局的变量对并发程序性能影响
还是不容忽略！

****** 对外层循环分组后并行

除了直接用 =@threads= ，我们还可以手动对外部循环分组嘛，然后每个线程分配到一小段
连续的外层循环，相当于粒度更大。

=Iterators= 提供了对 =Array= 分组的方法：
#+begin_src text
help?> Iterators.partition
  partition(collection, n)

  Iterate over a collection n elements at a time.

  Examples
  ≡≡≡≡≡≡≡≡≡≡

  julia> collect(Iterators.partition([1,2,3,4,5], 2))
  3-element Array{SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true},1}:
   [1, 2]
   [3, 4]
   [5]
#+end_src

利用这个函数，我们对外层循环的下标分组，然后每个线程只操作一组下标，这样有效避免了数据竞争发生。
#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

println("nthreads = ", Threads.nthreads())

function JGibbs7(N::Int, thin::Int)
  nt = Threads.nthreads()

  # mat = zeros(Float64, N, 2)
  mat = zeros(Float64, N, 2)

  # partition
  parts = Iterators.partition(1:N, N ÷ Threads.nthreads() + 1) |> collect

  Threads.@threads for p in parts
    x   = 0.
    y   = 0.
    for i in p
      for j in 1:thin
        x = rand(Gamma(3, 1/(y^2 + 4)))
        y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
      end
      mat[i,1] = x
      mat[i,2] = y
    end
  end

  mat
end

@btime JGibbs7(20000, 200);
#+end_src

#+RESULTS:
: nthreads = 6
: JGibbs7 (generic function with 1 method)
:   41.631 ms (34 allocations: 316.91 KiB)

这个结果和 =JGibbs6_1= 相差不大，都是已经充分利用了 6 个线程的计算资源。


*** 总结
本文从一名用户的角度，浅显地阐述了如何对一个函数进行优化，以及如何使用各类工具来
帮助我们分析程序的运行状况。我得出以下几个结论，供大家参考：
1. 使用纯 Julia 编写的程序性能的 *上限* 很高，完全不输于调用 FFI ，因此大家对此
   不应有过多的顾虑，直接用就完事了；
2. 尽管我们认为处理器的计算是耗时大头，程序运行时的内存反复分配也可能成为程序运
   行的瓶颈；
3. 在使用并发加速时应格外小心是否存在竞争的风险，能做到内聚就尽量做到内聚，否则
   将来总会掉到坑里；
4. 想发挥出 Julia 真正的性能，还是需要下一些功夫的，随手一写还真不一定比其它语言
   快；好在 Julia 社区提供了实用的性能分析工具，大大简化了优化的流程，这一点我十
   分赞赏。

[fn:1] 代码来自三爷的 gist :
https://gist.github.com/MitsuhaMiyamizu/5edf031a36cfb260381a70060a3fea4a
[fn:2] 这里使用 BenchmarkTools 中的 =@btime= 而不是 =@time= 是因为后者并不能将代 码编译的时间去掉，前者则能多次执行，取耗时最小值，有效避免了 AOT 对计时的影响。
[fn:3] ffi 即 Foreign function interface ，用于跨语言调函数，详见
https://en.wikipedia.org/wiki/Foreign_function_interface

** DONE VASP 收敛性测试的小脚本 :@PhysicalChemistry:VASP:Shell:ASE:
CLOSED: [2021-04-16 Fri 20:57]
:PROPERTIES:
:EXPORT_FILE_NAME: vasp-convergence-test-scripts
:EXPORT_DATE: [2021-04-16]
:END:

一般而言，在使用 VASP 计算体系之前都需要对一些参数做收敛性测试，侯老师[fn:: https://github.com/orivenlikon/vaspDoc/blob/master/%5Bmuchong.com%5Dvasp入门指南-复旦-侯柱峰.pdf]
曾写过一本VASP 入门手册，里面给了一些测试计算参数的小脚本，这里我
也给出一些我经常用的收敛性测试脚本，权当抛砖引玉了。

#+hugo: more

本文提供的测试脚本可以写进提交任务的脚本中，进而充分利用超算上多核、多节点的计算
资源。需要注意的是，这些脚本本身并不产生 VASP 的输入文件，而是在已有的文件基础上
进行修改。

*** =SIGMA= 的测试
和上面的使用前提一样， INCAR 应提前准备好。 SIGMA 收敛的标准通常是 dE 绝对值小于
1.0meV/atom 。

#+begin_src sh
#!/bin/bash
#SBATCH xx
...

set -e
set -o pipefail

VASP_EXEC="srun /path/to/vasp"  # "mpirun -np xxx" is also ok

date >> sigma.txt
for i in 0.8 0.5 0.3 0.1 0.08 0.05 ; do
    echo
    sed -i "s/^.*\\bSIGMA\\b.*$/        SIGMA = $i" INCAR
    eval ${VASP_EXEC}
    TS=$(grep "EENTRO" OUTCAR | tail -1 | awk '{print $5}')
    echo "$i    $TS" >> sigma.txt
done

echo "NIONS = " $(grep NIONS OUTCAR | awk '{print $12}') >> sigma.txt
#+end_src

*** =ENCUT= 的测试
使用前请先写好一个 INCAR ，并确保里面包含 =ENCUT= 字段，且 =ENCUT= 单独占一行
（否则同一行内的其它参数会被舍去）。通常而言，达到收敛的标志是相邻两次迭代的能量
小于 1.0meV/atom 。

#+begin_src sh
#!/bin/bash
#SBATCH xx
...

set -e
set -o pipefail

VASP_EXEC="srun /path/to/vasp"  # "mpirun -np xxx" is also ok

date >> encut.txt
for i in {200..500..50}; do
    sed -i "s/^.*\\bENCUT\\b.*$/        ENCUT = $i" INCAR
    eval ${VASP_EXEC}
    E=$(grep TOTEN OUTCAR | tail -1 | awk '{printf "%12.6f", $5}')  # Extract TOTEN from OUTCAR
    echo "$i    $E" >> encut.txt
done

echo "NIONS = " $(grep NIONS OUTCAR | awk '{print $12}') >> encut.txt
#+end_src

*** 晶格参数的测试
**** 晶格常数的测试

执行这个测试需要准备好 POSCAR ，这个测试不依赖 ASE 等包，因为它实质上是在更改
POSCAR 第二行的 scale factor 。这个测试只是相对粗糙的测试，因此这里就直接在原位
覆盖前一次的计算结果了。

#+begin_src sh
#!/bin/bash
#SBATCH xx
...

set -e
set -o pipefail

VASP_EXEC="srun /path/to/vasp"  # "mpirun -np xxx" is also ok

date >> a.txt
for i in $(seq 0.99 0.001 1.01)
do
  sed -i "2c $i" POSCAR
  echo -e "a = $i angstrom"
  eval ${VASP_EXEC}
  E=`grep "TOTEN" OUTCAR | tail -1 | awk '{printf "%12.6f", $5 }'`
  V=`grep "volume" OUTCAR | tail -1 | awk '{printf "%12.4f", $5}'`
  printf "a = %6.3f Vol = %10.4f Energy = %18.10f\n" $i $V $E >> a.txt
  tail -1 a.txt
done
echo -e "\n\n" >> a.txt#+end_src
#+end_src

**** 晶格长度的测试
在测试晶格的角度、长度时就不得不使用其它包了，Python 的 ASE 包提供了相对完善的基
础设施，这里在使用它来辅助完成晶格测试的工作。另外，在测试 Slab 的真空层厚度时也
可以使用这个脚本[fn:: 这个脚本要求晶格的 c 轴垂直于 a 轴和 b 轴]。

#+begin_src python
#!/usr/bin/env python3

import os
from ase.io import read as poscar_reader

poscar = poscar_reader("POSCAR")
cell = poscar.get_cell().copy()

for i in range(1, 7):
    cell[-1, -1] += 5.0             # Increase length along z axis by 5 angstroms each time
    poscar.set_cell(cell)
    dirname = "{:02}".format(i*5)
    if not os.path.exists(dirname):
        os.mkdir(dirname)           # create directories for each test
    poscar.write(dirname + "/POSCAR", vasp5=True, direct=True)
    for infile in ['INCAR', 'POTCAR', 'KPOINTS', 'sub_vasp_tahoma']:
        abspath = os.path.abspath(infile)
        os.symlink(abspath, dirname + "/" + infile)
        pass
    print("POSCAR saved in {}".format(dirname + "/POSCAR"))
    pass
#+end_src

用户可以根据自己需要随意更改晶格的参数，具体的需求可以通过阅读 ASE 的文档[fn::
https://wiki.fysik.dtu.dk/ase/ase/atoms.html 和
https://wiki.fysik.dtu.dk/ase/ase/geometry.html]来实现，这里就不一一列举了。

*** Slab 衬底层数的测试
一般而言，结构建模都是在 Materials Studio 上完成的（我现在也是如此），但如果有对
Slab 衬底做收敛性测试的需求，还是要借助一下 ASE ，它也内置一了些常见的 Slab 。

下面是一个生成不同层数 Ag(111) Slab 的脚本：

#+begin_src python
#!/usr/bin/env python3

import os
import numpy as np
from ase.build import fcc111
from ase.constraints import FixAtoms

for i in np.arange(1, 9):
    numstr = str(i)

    # generate 1x1 slab along a and b axis, this slab has `i` layers
    # vacuum is 20 angstrom
    slab = fcc111("Ag", size=(1, 1, i), vacuum=20)

    # Relax the first 2 layers and fix the others.
    c = FixAtoms(mask=[atom.tag > 2 for atom in slab])

    # Apply the constraint
    slab.set_constraint(c)
    print(slab)
    if not os.path.exists(numstr):
        os.makedirs(numstr+"/opt")
        os.makedirs(numstr+"/band")
        pass
    slab.write(numstr+"/opt/POSCAR", vasp5=True, direct=True)
    pass
#+end_src

对于其它金属， ASE 也有支持，详细说明请看它的文档[fn::
https://wiki.fysik.dtu.dk/ase/ase/build/build.html]。

** DONE VASP 偶极校正及功函数的计算 :@PhysicalChemistry:VASP:Python:ASE:DipoleCorrection:Workfunction:
CLOSED: [2021-04-23 Fri 16:44]
:PROPERTIES:
:EXPORT_FILE_NAME: vasp-dipol-correction-work-function
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :katex true :markup goldmark
:EXPORT_DATE: [2021-04-23]
:END:

水文一篇，介绍了如何用 VASP 添加偶极校正参数、计算 Slab 体系的功函数，以及如何找
真空能级。

#+hugo: more

*** 概念解释
**** 功函数
将一个固体内部的电子移动到真空所需的能量。（类似于光电效应方程中的逸出功）。

**** 真空能级
固体表面外真空中自由电子所具有的能量。换句话说，电子跑出固体表面并达到这个能级后
即可认为它自由 +免费+ 了。

**** 偶极校正
因 VASP 所适用的体系是周期性体系，使用它来模拟实验中的 Slab 模型时会取一个相当大
的真空层来隔绝相信两个周期中 Slab 的相互作用。理想情况下，真空层中的功函数应当是
一条水平的直线（函数值为定值）。但如果表面的两侧并非对称，即其中一侧吸附了分子时，
这两侧的功函数存在差异，此时如果不进行偶极校正，真空中的功函数会是一条斜线；而经
过偶极校正后，功函数会出现一个阶梯，阶梯两侧附近的曲接近水平。下图[fn:5]是一个例
子。

#+CAPTION:  DFT 曲线为未经过偶极校正的功函数， DFT-DC 曲线是经过偶极校正后的功函数
#+NAME: fig:DFT-DC1
[[./vasp-dipol-correction-work-function/VCL-2.png]]


*** 如何计算
**** 偶极校正
VASP 中直接使用 =LDIPOL= 和 =IDPOL= 即可开启它的偶极校正功能。

- =LDIPOL = .TRUE.= 表示打开偶极校正；
- =IDIPOL = 3= 表示偶极校正所修正的方向为第 3 个晶格矢量方向对应的方向，一般来说就是 \(z\) 轴；
- =DIPOL = <3 float values>= 表示体系的中心，以分数坐标表示；

上面几个 Flag 中一般来说 DIPOL 不用填，因为 VASP 手册中[fn:4]有一句
#+begin_quote
If the flag is not set, VASP determines, where the charge density averaged over
one plane drops to a minimum and calculates the center of the charge
distribution by adding half of the lattice vector perpendicular to the plane
where the charge density has a minimum (this is a rather reliable approach for
orthorhombic cells).
#+end_quote
不过有时不填它会导致体系 *非常* 难以收敛，如果遇到这各情况，最好还是手动算一下所
有原子 \(z\) 坐标的平均值，然后 =DIPOL = 0.5 0.5 <averaged z>= ，此时修正效果可
能并不好，读者需要：

1. 打开偶极校正和 =DIPOL = 0.5 0.5 <averaged z>= ，并弛豫结构到稳定；
2. 关闭 =DIPOL= ，并弛豫到结构稳定；
3. 关闭 =DIPOL= ，打开 =LVHAR = .TRUE.= ，并做静态计算，得到功函数；

偶极校正的标准是功函数出现台阶，并且台阶两边为水平，如果画出的功函数图不是这样，
就要考虑调整参数了。

**** 功函数
在 VASP 中 =LVHAR= [fn:1]参数可以使 VASP 输出体系的功函数文件 =LOCPOT= 。LOCPOT
文件本身是 Volumetric data ，它的格式与 CHGCAR 一样[fn:2]。一般而言，用户关心的
功函数是垂直于表面方向上的数据，因此在得到 LOCPOT 后需要对它做一点工作，即对 \(xy\)
平面内的数据做平均，然后乘以晶胞的体积，就得到我们需要的功函数信息。这里给出一个
脚本[fn:3]来完成这项工作：

#+INCLUDE: "./vasp-dipol-correction-work-function/plot-workfunc.py" src python :lines "26-71"

完整的脚本文件已经放 Gist[fn:3] 上，当然你也可以直接点击[[file:vasp-dipol-correction-work-function/plot-workfunc.py][它]]来下载。运行这个脚本后
得到的 Workfunction.pdf 和 locpot.dat 就是 \(z\) 方向上的功函数信息。

#+CAPTION: Workfunction.png 示例
#+NAME: fig:Workfunction
[[./vasp-dipol-correction-work-function/Workfunction.png]]


*** 真空能级
前面已经提到，真空能级可以读取 locpot.dat 真空部分的数据得到，其实当你打开
=LVHAR= 时，它也可以通过读取 OUTCAR 得到，比如

#+begin_src sh
$ grep vacuum OUTCAR
 vacuum level on the upper side and lower side of the slab         2.807         3.188
#+end_src

这里的 upper side vacuum level 是指 Slab 上表面的真空能级（图 [[fig:Workfunction]]
中 30A 处的平台）， lower side vacuum level 自然就是下表面的真空能级了
（图 [[fig:Workfunction]] 中 35A 处的平台）。

需要注意的是，从 OUTCAR 中 grep 出的真空能级没有经过费米能级修正，它需要减去
OUTCAR 中的 E-fermi 才是实验中测得的功函数的值。所幸的是 plot-workfunc.py 已经
做了这个工作，用 locpot.dat 画出来的图就对应实验所测结果。

[fn:1] 在 VASP 5.2.12 之前的版本中 =LVTOT= 输出的文件是静电势的贡献；但在 VASP
5.2.12 及之后的版本中，交换关联势的贡献也会被写入 =LOCPOT= 中， =LVHAR= 输出的部
分才是真正静电势的贡献，也就是我们想要的部分；
[fn:2] CHGCAR 的格式请见 VASP 手册 https://www.vasp.at/wiki/index.php/CHGCAR ；
[fn:3] 完整脚本见 https://gist.github.com/Ionizing/1ac92f98e8b00a1cf6f16bd57694ff03 。
[fn:4] https://www.vasp.at/wiki/index.php/DIPOL
[fn:5] 图源： http://exciting-code.org/nitrogen-dipole-correction

** TODO 组内集群折腾实录
** TODO 镜像态的那些坑 :@PhysicalChemistry:VASP:IPS:ImagePotentialStates:
:PROPERTIES:
:EXPORT_FILE_NAME: issues-with-ips
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :katex true :markup goldmark
:EXPORT_DATE: [2021-04-28]
:END:

本文是帮实验组计算表面态与镜像态相关性质时所遇到一些坑的总结。

#+hugo: more

#+begin_quote
限于 DFT 理论上的缺陷（使用指数函数逼近库仑势，从而加速收敛）， DFT 并不能算准
IPS 的能级（误差在 \(\pm 0.3eV\)左右），但有的实验又需要从 DFT 计算获得一些关于
IPS 的信息，于是即使 DFT 不能算准，也无大碍。在这个过程中本人似乎不止一次掉入坑
中，于是把这个过程记录下来，即便对后人没什么帮助，也算是对自己学习印迹的一丝收藏
吧。
#+end_quote

*** 表面态与镜像态
**** 表面态(Surface States, SS)
顾名思义，表面态就是在物体 *表面* 附近存在的电子态[fn:1]。表面意味着边界的存在，
边界外是真空，边界内是原子。正因为存在从体相到真空的剧烈变化，表面的原子存在不饱
和键，即悬挂键。这些悬挂键由那些在体相内本应成键的电子贡献，受这些电子影响，物体
的 *表面* 会出现一些新的、相对弥散的电子态，这些电子态被称为表面态。

**** 镜像态(Image Potential States, IPS)
将一个电荷放在无限大的导体表面（这里假设表面是平面），导体内部会发生极化，导致内
部电荷重新分布，从而产生一个静电势。这个静电势等效于导体内一个带相反电性的镜像电
荷产生的静电势，因而被称为镜像势。电子因镜像势会在导体表面 *外* 形成一些相对弥散
的态，这些态就是镜像态。

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./issues-with-ips/ips1.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 800 :iminoptions -density 720
#+begin_src latex
\scalebox{2.0}{
    \begin{tikzpicture}[thick]
        \def\z{3}
        \def\ze{\z/4*3}

        %% Medias
        \fill[blue!50,opacity=.3] (-\z-1/2,2) rectangle (0, -0.5);

        \node at (-1,1.5) {$\epsilon_r$};
        \node at (1,1.5) {$\epsilon_0$};

        \node at (-1,0.5) {Conductor};
        \node at (1,0.5) {Vacuum};

        %% Axes
        \node at (0,0) [below left] {$O$};
        \draw[-stealth] (-\z-1/2,0) -- (\z+1/2,0);
        \draw[thick,dashed] (0,-0.5) -- (0,2);

        %% Define two charges
        \node[fill=black!40,circle,label=above right:$e$]  (e) at  (\ze,1) {$-$};
        \node[fill=black!30,circle,label=above left:$-\beta e$] (be) at (-\ze,1) {$+$};

        %% Connect two nodes
        \draw[dashed,thin,gray] (be) -- (e);

        %% vertical line to z-axis
        \node (ex) at (\ze,0) [below] {$z$};
        \node (bex) at (-\ze,0) [below] {$-z$};
        \draw[thin,dashed] (ex) -- (e);
        \draw[thin,dashed] (bex) -- (be);
    \end{tikzpicture}
}
#+end_src

#+caption: 镜像电荷示意图， 0+ 侧是真空， 0- 侧是相对介电常数为 epsilon_r 的导体内部
#+RESULTS:
[[file:./issues-with-ips/ips1.svg]]

镜像势的势能曲线是反比例曲线：

\[ V(z) = - \frac{\beta e^2}{4\pi \epsilon_{0} \cdot 4z} \]

上式中 \(\beta = \displaystyle\frac{\epsilon_r-1}{\epsilon_r+1}\)

所以电子满足方程：

\[ \begin{aligned}
\frac{\hbar^2}{2m_e} \nabla^2 \Psi + V(z)\Psi &={} E\Psi \newline
\frac{\hbar^2}{2m_e} \nabla^2 \Psi - \frac{\beta e^2}{4\pi \epsilon_{0} \cdot 4z} \Psi &={} E\Psi
\end{aligned} \]

这个方程看起来很眼熟，它十分类似于氢原子 Schrodinger 方程。由于这个电子只在
\(z\) 方向上受镜像电荷作用，因而在 \(xy\) 方向上是自由的，所以它能量可以通过求解
一维氢原子 Schrodinger 方程得到：

\[ E_n = -\frac{m\beta^2 e^4}{2\hbar^2 n^2}\\;, \quad n=1,2, ... \]

其中 \(n\) 是主量子数。所以镜像态也可以根据主量子数的不同来区分出不同的能级。求
解过程可以在一篇文章中查到；镜像势的表达式的推导过程详见附录。

严格地说，镜像态也是表面态的一种[fn:2]。一般而言，镜像态在真空能级以下 1eV 以内，
DFT 算出的 IPS 能级可能会超过真空能级，但在实际上是不太可能的，即使真的有，实验
上也不大能测得到。

*** 计算过程
事实上计算出镜像态，并不需要改太多的东西。之后我们会结合 Ag(111) 的例子来分别阐
述这些过程。

**** 计算参数

***** 足够的空带
如果体系比较小， VASP 默认取的 =NBANDS= 是足够找到 IPS 的；但如果体系有超胞，默
认的 =NBANDS= 可能不太会覆盖到 IPS ，这时需要增加 =NBANDS= ，一般加到真空能级以
上 2eV 就足够了。关于真空能级怎么算，详见之前的博文。

***** 足够的真空层
这一点毋庸置疑，但真空层究竟取多少算「足够」呢？这里做了一个收敛性测试：

***** 偶极校正
如果 Slab 表面没有吸附其它原子/分子，则不必对体系进行偶极校正，否则需要校正，具
体过程参见之前的博文。

**** 验证计算结果
这里的「验证」与其说是验证，不如说是寻找。前面提到， IPS 是一种相对「弥散」的态，
它「弥散」的性质决定了怎么去 Identify IPS 。这里总结了几种「找」 IPS 的方法。

***** PDOS 法
一个态比较「弥散」说明它的局域性（locality）比较低，反映在物理图像里就是它投影在
原子上的态比较少。因此我们可以在通过不同能带在原子上的投影大小来判断它是否是 IPS。

幸运地是 VASP 可以通过 =LORBIT = .TRUE.= 来输出 =PROCAR= 文件，它包含了每个能带
在所有原子上的投影大小，顺便说一句， =PROCAR= 还包含不同角动量的投影大小。

先结构弛豫，再进行自恰计算得到 =PROCAR= 后，可以通过以下方法查看这个态在所有原子
上的投影之和：

打开 =PROCAR= ，定位到真空能级 [fn:3] 附近 \(\Gamma\) 点的能带
    #+begin_src
band    35 # energy    3.23957699 # occ.  0.00000000

ion      s     py     pz     px    dxy    dyz    dz2    dxz  x2-y2    tot
    1  0.002  0.000  0.000  0.000  0.000  0.000  0.002  0.000  0.000  0.004
    2  0.001  0.000  0.001  0.000  0.000  0.000  0.000  0.000  0.000  0.002
    3  0.000  0.000  0.001  0.000  0.000  0.000  0.000  0.000  0.000  0.001
    4  0.001  0.000  0.001  0.000  0.000  0.000  0.001  0.000  0.000  0.002
    5  0.002  0.000  0.000  0.000  0.000  0.000  0.002  0.000  0.000  0.004
tot    0.005  0.000  0.004  0.000  0.000  0.000  0.004  0.000  0.000  0.013
#+end_src
看最后一行 =tot 0.005 ...= ，最右边也有一个 =tot= ，两者交叉的的值 =0.013= 即为
这条能带在整个系统上的投影大小，换言之，局域度的大小。那么这个值越小则它是 IPS
的可能性越高。比如上面的能带 PDOS 中整体的 PDOS 之和只有 0.013 ，说明它的局域度
很小，那么这个态非常弥散，有可能是 IPS 。

***** 实空间分布法
仅仅是通过能带的 PDOS 还不足以确认这条带是不是 IPS ，有些费米能级附近的带总体
PDOS 也很小，但不是 IPS 。这时就需要其它方法来看了，比如本节要介绍的实空间分布法。

IPS 在实空间的分布特征相当明显：
1. 它们在表面以外，并且随着主量子数的升高有着对应个数的波包；
2. 每个波包对应的空间分布呈明显的近自由电子态的特征。

如下图中 A [fn:4]所示：

#+CAPTION: 左上：镜像势的原理示意图；A: Cu(100) 表面的镜像势曲线与 z 方向上镜像态波包分布 (n=1,2,3)；B: 2PPE 实验信号图。
#+NAME: fig:ips-en-cu100
[[./issues-with-ips/ips-en-cu100.png]]

对于第一个特征，我们可以对波函数的模平方作 \(z\) 方向上的分布，数出表面外有多少
个峰，注意区分 Slab 的上表面和下表面，只有上表面的波包应该被计入在内。

如果只看 \(z\) 方向上的波函数觉得不放心，可以把某条带在实空间的分布画出来，如果
它在真空中，并且上下表面近似为平面，即可认为它是 IPS ，如下图所示。



***** 能带法
以上是在单点能静态计算的基础上进行的分析，如果已经画出了这个体系的能带图，从能带
图上可以更加清晰地反映出 IPS 的特征。

能带图的横坐标量纲是动量，纵坐标是能量。一个自由电子的能量全部由动能贡献，因此它
的能量与动量的关系就是

\[ E = E_k = \frac{p^2}{2m} = \frac{g^2}{2m_e} \]

\(E\) 与 \(g\) 呈二次函数式色散关系，那么只要某个带的色散关系与抛物线相似，就有
理由认为某能带可能是 IPS ，比如下面的图中 4 eV 附近的能带明显呈抛物线色散关系，
而它们也确实是 IPS 。


**** 一个例子
这里将以一个 Ag(111) 体系为例，将上述过程走一遍，以便大家对上面的描述有个直观的
印象。

*** 附录
**** 镜像势表达式的推导
这里我们更一般地推导两种介质界面处镜像势的表达式。

假设有两种介质 1 和 2，它们的介电常数分别为 \(\epsilon_1\) 和 \(\epsilon_2\) ，有电荷
\(q\) 在介质 1 中，如下图所示：

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./issues-with-ips/ips2.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 800 :iminoptions -density 720
#+begin_src latex
\scalebox{2.0}{
    \begin{tikzpicture}[thick]
        \def\z{3}
        \def\ze{\z/4*3}

        %% Medias
        \fill[blue!50,opacity=.3] (-\z-1/2,2) rectangle (0, -0.5);
        \node at ( 3,1.5) {$\epsilon_1$};
        \node at (-3,1.5) {$\epsilon_2$};

        %% Axis
        \node at (0,0) [below left] {$O$};
        \draw[thick,-stealth] (-\z-1/2,0) -- (\z+1/2,0);
        \draw[thin,dashed] (0, -0.5) -- (0,2);

        %% Charges
        \node[label=above right:$q$] (e1) at ( \ze,0) {};
        % \node[label=above left:$\beta q$] (e2) at (-\ze,0) {};
        \fill[black] (e1) circle (0.07);
        % \fill[black] (e2) circle (0.07);

    \end{tikzpicture}
}
#+end_src

#+RESULTS:
[[file:./issues-with-ips/ips2.svg]]

现在将问题分成两部分来看：分别计算介质 1 和介质 2 中电场强度。

在介质 1 中任取一点 \(P\) ，同时认为 \(q\) 的镜像电荷等效带电量为 \(q'\) ，则
\(P\) 点的受力如下图所示

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./issues-with-ips/ips3.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 800 :iminoptions -density 720
#+begin_src latex
\scalebox{2.0}{
    \begin{tikzpicture}[thick,>=stealth]
        \def\z{3}
        \def\ze{\z/4*3}

        %% Medias
        % \fill[blue!50,opacity=.3] (-\z-1/2,2) rectangle (0, -0.5);
        \node at ( 3,1.5) {$\epsilon_1$};
        \node at (-3,1.5) {$\epsilon_1$};

        %% Axis
        \node at (0,0) [above left] {$O$};
        \draw[thick,->] (-\z-1/2,0) -- (\z+1/2,0) node [above left] {$z$};
        \draw[thin,dashed] (0, -0.5) -- (0,2);

        %% Charges
        \node[label=above:$q$] (e1) at ( \ze,0) {};
        \node[label=above:$q'$] (e2) at (-\ze,0) {};
        \fill[black] (e1) circle (0.05);
        \fill[black] (e2) circle (0.05);

        \draw (\ze, -0.1) -- (\ze, -0.3);
        \draw (-\ze, -0.1) -- (-\ze, -0.3);

        \draw[<->] (-\ze,-0.2) -- node[below] {$d$} (0,-0.2);
        \draw[<->] (\ze,-0.2) -- node[below] {$d$} (0,-0.2);
        \draw[<->] (0, 0.2) -- node[above] {$z$} (1,0.2);

        %% P point
        \node[label=above:$P$] (p) at (1,1.5) {};
        \fill[black] (p) circle (0.05);
        \draw[dashed] (p) -- node[above right] {$R_1$} (e1);
        \draw[dashed] (p) -- node[above left] {$R_2$} (e2);

        \draw[dashed] (p) -- node[right]{$r$} (1,0);
        \draw (1,0.15) -| (1.15,0);
    \end{tikzpicture}
}
#+end_src

#+RESULTS:
[[file:./issues-with-ips/ips3.svg]]

此处的电场强度为

\[\begin{aligned}
V_1 &={} \frac{1}{4\pi \epsilon_1} \left( \frac{q}{R_1} + \frac{q'}{R_2} \right) \newline
R_1 &={} \sqrt{(z-d)^2 + r^2} \newline
R_2 &={} \sqrt{(z+d)^2 + r^2} \newline
E_z &={} -\frac{\partial V_1}{\partial z} = \frac{1}{4\pi\epsilon_1}
        \left[ \frac{q(z-d)}{R_1^3} + \frac{q'(z-d)}{R_2^3} \right] \newline
E_r &={} -\frac{\partial V_1}{\partial r} = \frac{1}{4\pi\epsilon_1}
        \left[ \frac{qr}{R_1^3} + \frac{q' r}{R_2^3} \right] \newline
\end{aligned}\]

现在考虑介质 2 中的电场强度，由于经过一个介面，介电常数分布发生了改变，所以在介
质 2 中所感受到的原来电荷的等效电荷为 \(q''\) 。

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./issues-with-ips/ips4.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 800 :iminoptions -density 720
#+begin_src latex
\scalebox{2.0}{
    \begin{tikzpicture}[thick,>=stealth]
        \def\z{3}
        \def\ze{\z/4*3}

        %% Medias
        \fill[blue!50,opacity=.3] (-\z-1/2,2) rectangle (\z+1/2, -0.6);
        \node at ( 3,1.5) {$\epsilon_2$};
        \node at (-3,1.5) {$\epsilon_2$};

        %% Axis
        \node at (0,0) [above right] {$O$};
        \draw[thick,->] (-\z-1/2,0) -- (\z+1/2,0) node [above left] {$z$};
        \draw[thin,dashed] (0, -0.5) -- (0,2);

        %% Charge q''
        \node[label=above:$q''$] (e3) at (\ze,0);
        \fill[black] (e3) circle (0.05);

        \draw (\ze, -0.1) -- (\ze, -0.3);
        \draw[<->] (\ze, -0.2) -- node[below] {$d$} (0,-0.2);

        %% P point
        \node[label=left:$P$] (p) at (-1,1.5);
        \fill[black] (p) circle (0.05);
        \draw[dashed] (p) -- node[above right] {$R_3$} (e3);
        \draw[dashed] (p) -- node[right] {$r$} (-1,0);
        \draw (-1,0.15) -| (-0.85,0);

        \draw (-1,-0.1) -- (-1,-0.3);
        \draw[<->] (-1,-0.2) -- node[below] {$z$} (0,-0.2);
    \end{tikzpicture}
}
#+end_src

#+RESULTS:
[[file:./issues-with-ips/ips4.svg]]

P 点的电场强度可以计算出来：

\[\begin{aligned}
V_2 &={} \frac{1}{4\pi\epsilon_2} \frac{q''}{R_3} \newline
R_3 &={} \sqrt{(z-d)^2 + r^2} \newline
E_z^{(2)} &={} -\frac{\partial V_2}{\partial z} =
                \frac{1}{4\pi\epsilon_2} \frac{q'' (z-d)}{R_3^3} \newline
E_r^{(2)} &={} -\frac{\partial V_2}{\partial r} =
                \frac{1}{4\pi\epsilon_2} \frac{q'' r}{R_3^3} \newline
\end{aligned}\]


在界面处应用导体介质界面上的边界条件：

\[\begin{cases}
z = 0 \implies R_1 = R_2 = R_3 = R \newline
D_z^{(1)} = D_z^{(2)} \newline
E_r^{(1)} = E_r^{(2)} \newline
\end{cases}\]

即：

\[\begin{aligned}
\epsilon_1 E_z^{(1)} & = {} \epsilon_2 E_z^{(2)} \newline
\implies \epsilon_1 \frac{1}{4\pi\epsilon_1} \frac{(q-q')d}{R^3} & = {}
         \epsilon_2 \frac{1}{4\pi\epsilon_2} \frac{q'' d}{R^3} \newline
\implies q - q' &={} q''
\end{aligned}\]

\[\begin{aligned}
E_r^{(1)} &={} E_r^{(2)} \newline
\implies \frac{1}{4\pi\epsilon_1} \frac{(q+q')r}{R^3} &={}
         \frac{1}{4\pi\epsilon_2} \frac{q'' r}{R^2} \newline
\implies \frac{q+q'}{\epsilon_1} &={} \frac{q''}{\epsilon_2}
\end{aligned}\]

联立上面两式，可以得到

\[ q' = -\frac{\epsilon_2 - \epsilon_1}{\epsilon_2 + \epsilon_1} q \]

如果用相对介电常数 \(\epsilon_r = \dfrac{\epsilon_2}{\epsilon_1}\) ，上面式子还
能简化为

\[ q' = -\frac{\epsilon_r - 1}{\epsilon_r + 1} q = -\beta q \]

[fn:1] Wikipedia Surface States item https://en.wikipedia.org/wiki/Surface_states
[fn:2] Image potential surface states
https://iopscience.iop.org/article/10.1088/0031-8949/36/4/009/pdf
[fn:3] 真空能级可以在 =OUTCAR= 里找到（ =grep vacuum OUTCAR= ）
[fn:4] 图片来自 https://www.uni-marburg.de/fb13/researchgroups/of/dynamics/impot.html
[fn:5] 2PPE: Two-photon photoemission spectroscopy of image states. Photonic
Probes of Surfaces, P. Halevi, Ed. (Elsevier, Amsterdam, 1995), pp. 347-411
** TODO Rsgrad 开发收获
** TODO Haskell 学习笔记
