:CONFIG:
#+HUGO_BASE_DIR: ../
#+HUGO_FRONT_MATTER_FORMAT: yaml
#+SETQ_TODO: TODO DRAFT DONE
#+PROPERTY: header-args :eval never-export
#+OPTIONS: toc:3 author:nil
:END:


* Table of Contents    :TOC_2:
- [[#about][About]]
- [[#external-link][External-link]]
- [[#posts][Posts]]
  - [[#新的旅程][新的旅程]]
  - [[#记一次-julia-代码性能优化过程][记一次 Julia 代码性能优化过程]]
  - [[#vasp-收敛性测试的小脚本][VASP 收敛性测试的小脚本]]
  - [[#vasp-偶极校正及功函数的计算][VASP 偶极校正及功函数的计算]]
  - [[#组内集群折腾实录][组内集群折腾实录]]
  - [[#镜像态的那些坑][镜像态的那些坑]]
  - [[#二维-ising-model-的-julia-实现][二维 Ising Model 的 Julia 实现]]
  - [[#使用数值方法求解单电子-schrodinger-方程][使用数值方法求解单电子 Schrodinger 方程]]
  - [[#简易-dft-玩具][简易 DFT 玩具]]
  - [[#利用-const-generics-实现编译期量纲分析][利用 Const Generics 实现编译期量纲分析]]

* DONE About :about:
CLOSED: [2021-4-13 Tue]
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_HUGO_SECTION: ./
:EXPORT_HUGO_MENU: :menu main
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :weight 50
:EXPORT_DATE: [2021-04-13]
:END:

A Ph.D candidate who majors in physical chemistry.

| Abilities | Level[fn:1] |
|-----------+-------------|
| C/C++     | Beginner    |
| Rust      | Beginner    |
| LaTeX     | Newbie      |
| VASP      | Beginner    |
| Linux     | Beginner    |

[fn:1] https://english.stackexchange.com/questions/83832/list-of-expertise-levels-from-beginner-to-expert


* DONE External-link
CLOSED: [2021-04-16 Fri 21:26]
:PROPERTIES:
:EXPORT_FILE_NAME: external-link
:EXPORT_HUGO_SECTION: ./
:EXPORT_HUGO_MENU: :menu main
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :weight 60
:EXPORT_DATE: [2021-04-16]
:END:

|-----------+-----------------------------------|
| Person    | Link                              |
|-----------+-----------------------------------|
| Liam0205  | https://liam.page/about/          |
| Mr. Joker | https://mrjokersince1997.gitee.io |
|-----------+-----------------------------------|


* Posts                :Posts:
:PROPERTIES:
:EXPORT_HUGO_SECTION: post
:END:

** DONE 新的旅程 :@杂项:回归:模板:配置:
CLOSED: [2021-04-14 Wed 16:15]
:PROPERTIES:
:EXPORT_FILE_NAME: a-new-journey
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :katex true :markup goldmark
:END:

这是回归博客写作后的第一篇文章

#+hugo: more

*** 回归
时光荏冉，已经好久没有更新博客了，上一次写博客还是去年寒假疫情在家时期。

这一年多以来总算把与实验组合作的几个工作结束了（第一次实践使用 VASP ），这几个工
作感觉能总结的地方不多，都是细节居多，但坑还是不少的。我自己的工作做了快两年了
（看来平时没少摸鱼），在去年底它的进度有了 180 度转变，这还多亏了导师的嘱托，让
我在补充图表时 Review 了一下之后的结果，一看就发现之前的结论完全错误，于是重新跑
了一下 NAMD ，这次的结果终于符合「预期」了，但现在似乎又遇到了一些不大不小的问题，
即能带交叉的处理，目测解决它又要费些时间了（而且还中间还有其它实验组的东西要做）。

说了这段时间自己在做什么，下面就该讲博客相关的东西了。

*** 博客相关
关于博客，我这次决心将它迁移到 Hugo 框架下，配合 Org-mode 和 ox-hugo 使用，至少
到现在体验挺好：
- Hugo 很快，生成静态页面耗时在 ms 量级，比 Hexo 不知道高到哪里去了；
- Org-mode 很强大，谁用谁知道；
- 私以为 Jane 主题足够简约，也留了足够的空间折腾。

近期做了些工作，我会把心得总结起来放到博客上，供自己和小伙伴们参考～

**** 配置、模板
以下是写博客时可能要用到的一些模板/配置，仅供自己参考了。

- Org-mode 中 CJK 文档的 soft space 问题，已经有人给出了解决方案[fn:: http://zwz.github.io] ：
#+begin_src elisp
(defun clear-single-linebreak-in-cjk-string (string)
"clear single line-break between cjk characters that is usually soft line-breaks"
(let* ((regexp "\\([\u4E00-\u9FA5]\\)\n\\([\u4E00-\u9FA5]\\)")
        (start (string-match regexp string)))
    (while start
    (setq string (replace-match "\\1\\2" nil nil string)
            start (string-match regexp string start))))
string)

(defun ox-html-clear-single-linebreak-for-cjk (string backend info)
(when (org-export-derived-backend-p backend 'html)
    (clear-single-linebreak-in-cjk-string string)))

(eval-after-load "ox"
  '(add-to-list 'org-export-filter-final-output-functions
                'ox-html-clear-single-linebreak-for-cjk))
#+end_src
- 添加链接时使用 src_elisp[:exports code]{C-c C-l} ， Doom-Emacs 会提示你输入链
   接的 URL 和 description；
- 使用 Inline code 时，参考它[fn:: https://stackoverflow.com/questions/16186843/inline-code-in-org-mode/16193498#16193498]： =src_sh[:exports code]{echo -e "test"}= ；
- =:PROPERTIES:= 中 =:@cat:= 定义了一个 category =cat= ， =:foo:= 定义了一个 tag =foo= ，
  =:@cat:foo:bar:= 则分别定义了一个 category =cat= ，两个 tags =foo= 、 =bar= ；
- 每篇文章标题前使用 =S-left= 或 =S-right= 可以切换 =TODO= 和 =DONE= 的状态；输
  入数学公式时，需要在 subtree 的 =:PROPERTIES:= 里加上
  =:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :katex true :markup goldmark= 。

   此时 =\(F=ma\)= 表示 inline equation ，输出 \(F=ma\) ； =\[F=ma\]= 表示
  displaystyle equation 。（冷知识[fn::
  https://orgmode.org/worg/org-tutorials/org-latex-preview.html]： Orgmode 支持
  即时渲染公式： =C-c C-x C-l= 会把当前公式渲染好并以 png 的形式插入当前窗口，重
  复这个操作可以关闭预览）

   现在试试一个稍稍复杂点的公式：

\[ \begin{aligned} \nabla \times \vec{\mathbf{B}} - \frac1c
\frac{\partial\vec{\mathbf{E}}}{\partial t} & = \frac{4\pi}{c}\vec{\mathbf{j}}
\newline \nabla \cdot \vec{\mathbf{E}} & = 4 \pi \rho \newline \nabla \times
\vec{\mathbf{E}} + \frac1c \frac{\partial\vec{\mathbf{B}}}{\partial t} & =
\vec{\mathbf{0}} \newline \nabla \cdot \vec{\mathbf{B}} & = 0 \end{aligned} \]

- 使用脚注来代替文献的上标[fn:: https://orgmode.org/manual/Creating-Footnotes.html]
  ，有三种方式：
  1. 声明和定义分离的脚注：在要添加脚注的地方声明 =[fn:NAME]= ，然后在其它地方定
     义这个脚注 =[fn:NAME] some description here ...= ；
  2. 行内定义的脚注：直接使用 =[fn:: some description here ... ]= ，这种方法不需要命名，可谓对程序员十分友好了 23333 ；
  3. 带名字的行内脚注： =[fn:NAME: some description here ...]= 。

**** 图片等外部文件的引用
这一节单独列出来是因为它比数学公式还要难处理，根据 =ox-hugo=[fn:: https://ox-hugo.scripter.co] 的说明，现在有三种引用图片的方法：

1. 使用相对路径：直接把图片放到 =<HUGO_BASE_DIR>/static/= 里，然后引用时可以省略
   =<HUGO_BASE_DIR>/static/= 前缀，例如有一个文件路径是
   =<HUGO_BASE_DIR>/static/image/foo.png= ，引用它时可以这样写：
   =[[image/foo.png]]= ；
2. 使用绝对路径：例如有一个路径是 =~/some/path/foo.png= ，引用它时可以使用
   =[[~/some/path/foo.png]]= ，此时不光在 orgmode 里可以直接预览图片， =ox-hugo=
   在导出时还会把它复制到 =<HUGO_BASE_DIR>/static/ox-hugo/= 里并生成链接；
3. 使用图床：现在 GitHub ， GitLab 等也可以用作图床，并且有成熟的软件来做这件事
   比如 PicGo[fn:: https://github.com/Molunerfinn/PicGo] 。把图片传给图床后，图
   床会返回一个链接，直接把它贴在 orgmode 里就能实现引用图片的效果。但之前我用七
   牛云的图床一段时间后七牛云直接拒绝被薅，改了域名，我也就对图床产生一些顾虑
   +，而且使用图床后一个缺点是，它降低了每篇文章的内聚度，增加了对外部的耦合（掉个
   书袋233）+ 。

因此我还是决定把图片等外部文件放在 =<HUGO_BASE_DIR>/content-org/= 里，每篇文章单
独建一个文件夹，然后使用相对路径引用。下面是效果展示（它使用了
=[[./a-new-journey/himehina.jpeg]]= ）：[[./a-new-journey/himehina.jpeg]]

**** 使用 TikZ 配合 Orgmode 进行画图 [2021-04-29] 更新
Orgmode 原生支持内嵌 \(\LaTeX\) 代码，自然也支持用 TikZ 画图。不过如果想要在利用
TikZ 的输出嵌入到博客中，还需要一点工作要做。
***** 输出 PNG 格式的图片
- 确保机器上已经安装了 ImageMagick 和 \(\LaTeX\) ；
- 在 config 中加入 =(setq org-latex-create-formula-image-program 'imagemagick)= ；

接下来就可以愉快玩耍了：

#+begin_src org
,#+header: :headers '("\\usepackage{tikz}")
,#+header: :results file graphics :file ./a-new-journey/test.png
,#+header: :exports results
,#+header: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
,#+begin_src latex
\begin{tikzpicture}
\draw[->] (-3,0) -- (-2,0) arc[radius=0.5cm,start angle=-180,end angle=0]
    (-1,0) -- (1,0) arc[radius=0.5cm,start angle=180,end angle=0] (2,0) -- (3,0);
\filldraw (-1.5,0) circle[radius=1mm];
\filldraw (1.5,0) circle[radius=1mm];
\end{tikzpicture}
,#+end_src

,#+RESULTS:
[[file:./a-new-journey/test.png]]
#+end_src

Eval 这个 source block 后即可得到：

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./a-new-journey/test.png
#+header: :exports results :imagemagick yes
#+header: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
#+begin_src latex
\begin{tikzpicture}
\draw[->] (-3,0) -- (-2,0) arc[radius=0.5cm,start angle=-180,end angle=0]
    (-1,0) -- (1,0) arc[radius=0.5cm,start angle=180,end angle=0] (2,0) -- (3,0);
\filldraw (-1.5,0) circle[radius=1mm];
\filldraw (1.5,0) circle[radius=1mm];
\end{tikzpicture}
#+end_src

#+RESULTS:
[[file:./a-new-journey/test.png]]


***** 输出 SVG 格式的图片
- 确保机器上已经安装了 \(\LaTeX\)

接下来的工作不那么优雅，我们需要修改一下 =ob-latex.el= 。

因为在 Orgmode 中 Eval 代码块时 Orgmode 会自动把代码块的内容加入预告写好的
Preamble 里生成一个临时文件，但当使用 =.svg= 结尾的输出文件名时它的 Preamble 是
这样的：

#+begin_src latex :exports code
\documentclass[preview]{standalone}
\def\pgfsysdriver{pgfsys-tex4ht.def}
%% Your \usepackage here
\begin{document}
%% Your code here
\end{document}
#+end_src

第二行的 =\def\pgfsysdriver= 需要放在 =\usepackage{tikz}= 后，或者使用 =htlatex=
才能编译，但 ob-latex 使用的是 =latex= ，而且这个过程只会提示 =PDF produced with
errors= ，导致输出的 SVG 是乱码。

查询 =ob-latex.el= 发现，这个 Preamble 是硬编码在 =org-babel-execute:latex= 里的：

#+begin_src elisp :exports code
 (defcustom org-babel-latex-preamble
   (lambda (_)
     "\\documentclass[preview]{standalone}
\\def\\pgfsysdriver{pgfsys-tex4ht.def}
 ")
   "Closure which evaluates at runtime to the LaTeX preamble."

...

          (with-temp-file tex-file
            (insert (concat
                     "\\documentclass[preview]{standalone}
\\def\\pgfsysdriver{pgfsys-tex4ht.def}
 "
                     (mapconcat (lambda (pkg)
                                  (concat "\\usepackage" pkg))
#+end_src

那问题就好办了，直接删掉两处 =\\def\\pgfsysdriver{pgfsys-tex4ht.def}= ，并重新
build （我使用的是 DoomEmacs ，运行 =~/.emacs.d/bin/doom build= ），然后就可以
正常导出了。

#+begin_src org
,#+header: :headers '("\\usepackage{tikz}")
,#+header: :results file graphics :file ./a-new-journey/test.svg
,#+header: :exports results
,#+header: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
,#+begin_src latex
\begin{tikzpicture}
\draw[->] (-3,0) -- (-2,0) arc[radius=0.5cm,start angle=-180,end angle=0]
    (-1,0) -- (1,0) arc[radius=0.5cm,start angle=180,end angle=0] (2,0) -- (3,0);
\filldraw (-1.5,0) circle[radius=1mm];
\filldraw (1.5,0) circle[radius=1mm];
\end{tikzpicture}
,#+end_src

,#+RESULTS:
[[file:./a-new-journey/test.svg]]
#+end_src

输出以下图形：

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./a-new-journey/test.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 400 :iminoptions -density 600
#+begin_src latex
\begin{tikzpicture}
\draw[->] (-3,0) -- (-2,0) arc[radius=0.5cm,start angle=-180,end angle=0]
    (-1,0) -- (1,0) arc[radius=0.5cm,start angle=180,end angle=0] (2,0) -- (3,0);
\filldraw (-1.5,0) circle[radius=1mm];
\filldraw (1.5,0) circle[radius=1mm];
\end{tikzpicture}
#+end_src

#+RESULTS:
[[file:./a-new-journey/test.svg]]


其实看 =ob-latex.el= 似乎可以通过用户定义 =org-babel-latex-preamble= 来绕过硬编
码的 Preamble ，但经过测试发现并没有起作用，如果读者有更好方案，请务必联系我。

上面测试用的 TikZ 代码圴来自 Jonny Evans[fn:8]，同时感谢群组内[fn:9]大佬们的帮助。

[fn:8] https://www.homepages.ucl.ac.uk/~ucahjde/blog/tikz.html
[fn:9] https://t.me/emacs_zh

** DONE 记一次 Julia 代码性能优化过程 :@Programming:Julia:Optimization:ParallelProgramming:
CLOSED: [2021-04-16 Fri 13:06]
:PROPERTIES:
:EXPORT_FILE_NAME: a-try-on-julia-code-optimization
:EXPORT_DATE: [2021-04-16]
:END:

这是和某三爷讨论后对交流内容的整理。

#+hugo: more

众所周知， Julia 是一种高级通用动态编程语言，它专为科学计算而生。为了方便科研人
员使用，它的语法被设计得很像 MATLAB ，但比 MATLAB 更合理（譬如数组引用使用 =[]=
，而不是 =()= ）。作为一门很年轻的语言，它吸收了前辈们的很多优点，也有着自己的特
色，但最受人青睐的一点在于：尽管它是一门动态语言，却宣称拥有 C/C++ 一般的性能。
一般而言，动态语言的表现能力更为出色，能用更少的代码做更多的事，开发效率高；而静
态语言的编译器后端更容易优化，运行效率高。Julia 有动态性，开发效率毋庸置疑，一些
测评也显示 Julia 确实拥有很强的性能，但这是否意味着你随手写的一段代码就能有很高
并且达到预期的性能？我看未必。

*** 运行环境

| Processor | Intel Core i5 9600KF |
| Memory    | 16GB 3200MHz         |
| OS        | macOS 10.15.6        |
| Julia     | 1.5.1                |

*** 优化过程
**** 原始版本[fn:1]
废话不多说，直接开始正题，先来看今天的主角[fn:2]
#+begin_src ess-julia :results output :session *julia*
using Rmath;
using BenchmarkTools;

function JGibbs1(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = rgamma(1, 3, 1/(y*y + 4))[1]
            y = rnorm(1, 1/(x+1), 1/sqrt(2(x + 1)))[1]
        end
        mat[i,:] = [x,y]
    end
    mat
end;

@btime JGibbs1(20000, 200);
#+end_src

这是一段关于 Gibbs 采样的代码，它主要由两个循环组成，外部循环一次产生两个值，内
部循环是迭代式的，即下一次循环要用到上次循环的结果。很明显它引入了 R 的库，并用
R 的 =rgamma= 和 =rnorm= 实现，那么它的性能是怎样的呢？

#+RESULTS:
:   501.798 ms (8020002 allocations: 734.56 MiB)

根据原文的说法，它的性能已经比 =Rgibbs= 快 17 倍，比 =RCgibbs= 快 13 倍，已经是
比较令人满意的结果了。

**** 使用 C-ffi 的 =rgamma= 与 =rnorm=[fn:1]

由于直接用 R 写的代码可能并不是最快的，而且它还在内层循环里，所以我们有理由相信
使用 C-ffi[fn:3] 版的 =rgamma= 与 =rnorm= 会更快。

#+begin_src ess-julia :results output :session *julia* :exports both
using Rmath
import Rmath: libRmath
using BenchmarkTools
function JGibbs2(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = ccall((:rgamma, libRmath), Float64, (Float64, Float64), 3., 1/(y*y + 4))
            y = ccall((:rnorm, libRmath), Float64, (Float64, Float64), 1/(x+1), 1/sqrt(2*(x + 1)))
        end
        mat[i,:] = [x,y]
    end
    mat
end

@btime JGibbs2(20000, 200);
#+end_src

#+RESULTS:
: JGibbs2 (generic function with 1 method)
:   259.387 ms (20002 allocations: 2.14 MiB)

果然，使用 C-ffi 版的函数后性能又提升了一倍！

**** 去除外部依赖[fn:1]

尽管使用 C 的实现后， =JGibbs= 性能提升巨大，但依赖外部库多少有点让人感觉不爽，
毕竟它和 Julia 所宣称的高性能关系不是很大（核心部分是 C 的贡献，而不是 Julia）。
既然 Julia 也是高性能语言，何不拿纯 Julia 写一个 =JGibbs= 来比比？

Julia 是为科学计算而生，它的社区维护了一个统计学库 =Distributions= ，里面包含了
=gamma= 与 =norm= 分布的函数，可以用来替换 =rgamma= 和 =rnorm= ，写完之后是这个
样子：

#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

function JGibbs3(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y^2 + 4)), 1)[1]
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))), 1)[1]
        end
        mat[i,:] = [x,y]
    end
    mat
end

@btime JGibbs3(20000, 200);
#+end_src

#+RESULTS:
: JGibbs3 (generic function with 1 method)
:   550.624 ms (8020002 allocations: 734.56 MiB)

咦？看起来它还没有使用 R-ffi 的函数快！

那么问题出在哪呢？仔细看结果，除了时间之外还有两个数据，一个是执行一次该函数时所
分配内存的次数，另一个是函数执行期间分配内存的总量。我们回头看一下使用 C-ffi 的
版本，它的测试结果显示除了性能更强外，内存分配的次数和总量也更少！而且 8020002
恰好是 20002 的 400 倍左右，正好是 =thin=200= 的 2 倍。据此，我们可以猜想，在
=for j=1:thin ... end= 内部存在不必要的内存分配。

下面来进行验证。

**** 内存分配情况分析
取出循环内的一行代码，对它进行 profile ：
#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

@btime rand(Gamma(1.0, 1.0), 1)[1];
#+end_src

#+RESULTS:
:   39.136 ns (1 allocation: 96 bytes)

奇怪，一个只返回一个 Float64 值的函数怎么会存在内存分配？仔细看 =[1]= 这个细节，
问题可能出在这里。通过查看文档，发现 =rand(Gamma(...), 1)= 中最后一个参数表示返
回一个一维的 Array ，并且 Array 的大小是 1 ：
#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

@btime rand(Gamma(1.0, 1.0), 1)
#+end_src

#+RESULTS:
:   37.541 ns (1 allocation: 96 bytes)
: 1-element Array{Float64,1}:
:  0.2929698750637693

一个 Float64 的值有 64 位，共 8 字节（bytes），而刚刚代码中所返回只有一个
Float64 元素的 Array 竟然有 96 字节！既然我们每次只需要返回一个值，那为什么要画
蛇添足去生成一个 Array 呢，直接调用只生成一个值的原型不好吗？

#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

@btime rand(Gamma(1.0, 1.0), 1)
@btime rand(Gamma(1.0, 1.0))
#+end_src

#+RESULTS:
:   37.217 ns (1 allocation: 96 bytes)
: 1-element Array{Float64,1}:
:  0.9938638399122478
:   8.116 ns (0 allocations: 0 bytes)
: 1.8038508272928604

看，直接使用 =rand(Gamma(...))= 耗时只有 =rand(Gamma(...), 1)= 的 22% ，并且内存
的分配是 0 ！

有了这些结论，我们对 =JGibbs3= 修改后，有了下面的代码。

**** 去除内层循环的内存分配
#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

function JGibbs4(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        mat[i,:] = [x,y]
    end
    mat
end

@btime JGibbs4(20000, 200);
#+end_src

#+RESULTS:
: JGibbs4 (generic function with 1 method)
:   251.144 ms (20002 allocations: 2.14 MiB)

这个耗时结果就正常多了，而且比调用 C-ffi 的版本还快了一丢丢；内存的分配也没那么夸张了。

**** 去除外层循环的内存分配

但这并不是它的性能极限：它依然有 20002 次的内存分配。仔细观察外层循环部分，只有
一个 =mat[i,:] = [x,y]= ，通常人们会认为编译器把它循环展开，不涉及内存分配，但事
实并非如此：

#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools

mat = zeros(Int, 2, 2);
@btime mat[1, :] = [1, 2];
@btime mat[:, 1] = [1, 2];
@btime begin
    mat[1, 1] = 1;
    mat[1, 2] = 2;
    end;
@btime begin
    mat[1, 1] = 1;
    mat[2, 1] = 2;
    end;
#+end_src

#+RESULTS:
:   259.485 ns (2 allocations: 112 bytes)
:   220.621 ns (2 allocations: 112 bytes)
:   28.665 ns (0 allocations: 0 bytes)
:   27.603 ns (0 allocations: 0 bytes)

我们可以得出三个结论：
1. 在使用切片赋值时会涉及内存分配，直接使用循环则不会；
2. 小矩阵赋值时使用循环甚至手动展开循环性能更高；
3. Julia 的 Array 使用列主序，对第一个维度操作比对其它维度操作性能更高，但提升幅
   度有限。

于是我们把 =JGibbs4= 中外层循环的矩阵赋值展开，得到 =JGibbs5=

#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

function JGibbs5(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        mat[i,1] = x;
        mat[i,2] = y;
    end
    mat
end

@btime JGibbs5(20000, 200);
#+end_src

#+RESULTS:
: JGibbs5 (generic function with 1 method)
:   229.861 ms (2 allocations: 312.58 KiB)

它比 =JGibbs4= 又快了 20ms ！而且其中内存分配只有两次，已经相当令人满意了。如果
要进一步压榨它的性能潜力，我们可以交换 =mat= 的行列，使外层循环每次赋值时都在访
问第一个维度，限于篇幅原因，这里就不展开了。

**** 使用多线程加速

上面使用的方法都是在一个线程内操作，现在的机器普遍都用上的多核处理器，而超算上更
是单节点上配备了数十个处理器，如此多的计算资源不利用好岂不是暴殄天物。

那么 =JGibbs= 函数能被并行化吗？答案是肯定的。

它的内层循环粒度太小，线程切换的耗时占比太高，因此内层循环不适合并行化。而外层循
环的粒度适中，我们试试将它并行化。

****** 直接使用 =Threads.@threads=

Julia 原生支持多线程编程，并且提供了 =Threads.@threads= 宏来方便对循环并行化，于
是就有了下面的代码
#+begin_src ess-julia :results output :exports both :session *julia*
println("nthreads = ", Threads.nthreads())

using BenchmarkTools;
using Distributions;

function JGibbs6(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    x   = 0.
    y   = 0.
    Threads.@threads for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        mat[i,1] = x;
        mat[i,2] = y;
    end
    mat
end

@btime JGibbs6(20000, 200);
#+end_src

#+RESULTS:
: nthreads = 6
: JGibbs6 (generic function with 1 method)
:   420.151 ms (52000035 allocations: 915.84 MiB)
[fn:: 我在启动 =julia= 前对环境变量进行了修改 =export JULIA_NUM_THREADS=6= ，这
样 Julia 在运行时支持最大 6 个线程操作。]

这个结果很离谱。先不谈运行时间，单看它的内存分配量就知道它绝对是有问题的（至于为
什么多出来这么多的内存分配，我也还在寻找原因，如果您有什么见解，请务必发邮件告诉
我 ^_^）， =Julia= 一共开了 6 个线程来加速，但结果显示它反而使运行效率降低了，问
题出在哪呢？仔细看代码

#+begin_src ess-julia
    x   = 0.
    y   = 0.
    Threads.@threads for i = 1:N
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        ...
    end
#+end_src

每个线程内，都要对全局变量 =x= 和 =y= 进行修改，并且还要读取它们的值，这显然存在
竞争的现象。那如果把 =x= 和 =y= 移动到每个线程内部定义呢？

#+begin_src ess-julia :results output :session *julia* :exports both
println("nthreads = ", Threads.nthreads())

using BenchmarkTools;
using Distributions;

function JGibbs6_1(N::Int, thin::Int)
    mat = zeros(Float64, N, 2)
    Threads.@threads for i = 1:N
        x   = rand()
        y   = rand()
        for j = 1:thin
            x = rand(Gamma(3, 1/(y*y + 4)))
            y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
        end
        mat[i,1] = x;
        mat[i,2] = y;
    end
    mat
end

@btime JGibbs6_1(20000, 200);
#+end_src

#+RESULTS:
: nthreads = 6
: JGibbs6_1 (generic function with 1 method)
:   39.926 ms (33 allocations: 316.75 KiB)

这个结果相当令人满意了，内存的分配降低很多，看来读写全局的变量对并发程序性能影响
还是不容忽略！

****** 对外层循环分组后并行

除了直接用 =@threads= ，我们还可以手动对外部循环分组嘛，然后每个线程分配到一小段
连续的外层循环，相当于粒度更大。

=Iterators= 提供了对 =Array= 分组的方法：
#+begin_src text
help?> Iterators.partition
  partition(collection, n)

  Iterate over a collection n elements at a time.

  Examples
  ≡≡≡≡≡≡≡≡≡≡

  julia> collect(Iterators.partition([1,2,3,4,5], 2))
  3-element Array{SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true},1}:
   [1, 2]
   [3, 4]
   [5]
#+end_src

利用这个函数，我们对外层循环的下标分组，然后每个线程只操作一组下标，这样有效避免了数据竞争发生。
#+begin_src ess-julia :results output :session *julia* :exports both
using BenchmarkTools;
using Distributions;

println("nthreads = ", Threads.nthreads())

function JGibbs7(N::Int, thin::Int)
  nt = Threads.nthreads()

  # mat = zeros(Float64, N, 2)
  mat = zeros(Float64, N, 2)

  # partition
  parts = Iterators.partition(1:N, N ÷ Threads.nthreads() + 1) |> collect

  Threads.@threads for p in parts
    x   = 0.
    y   = 0.
    for i in p
      for j in 1:thin
        x = rand(Gamma(3, 1/(y^2 + 4)))
        y = rand(Normal(1/(x + 1), 1/sqrt(2*(x + 1))))
      end
      mat[i,1] = x
      mat[i,2] = y
    end
  end

  mat
end

@btime JGibbs7(20000, 200);
#+end_src

#+RESULTS:
: nthreads = 6
: JGibbs7 (generic function with 1 method)
:   41.631 ms (34 allocations: 316.91 KiB)

这个结果和 =JGibbs6_1= 相差不大，都是已经充分利用了 6 个线程的计算资源。


*** 总结
本文从一名用户的角度，浅显地阐述了如何对一个函数进行优化，以及如何使用各类工具来
帮助我们分析程序的运行状况。我得出以下几个结论，供大家参考：
1. 使用纯 Julia 编写的程序性能的 *上限* 很高，完全不输于调用 FFI ，因此大家对此
   不应有过多的顾虑，直接用就完事了；
2. 尽管我们认为处理器的计算是耗时大头，程序运行时的内存反复分配也可能成为程序运
   行的瓶颈；
3. 在使用并发加速时应格外小心是否存在竞争的风险，能做到内聚就尽量做到内聚，否则
   将来总会掉到坑里；
4. 想发挥出 Julia 真正的性能，还是需要下一些功夫的，随手一写还真不一定比其它语言
   快；好在 Julia 社区提供了实用的性能分析工具，大大简化了优化的流程，这一点我十
   分赞赏。

[fn:1] 代码来自三爷的 gist :
https://gist.github.com/MitsuhaMiyamizu/5edf031a36cfb260381a70060a3fea4a
[fn:2] 这里使用 BenchmarkTools 中的 =@btime= 而不是 =@time= 是因为后者并不能将代 码编译的时间去掉，前者则能多次执行，取耗时最小值，有效避免了 AOT 对计时的影响。
[fn:3] ffi 即 Foreign function interface ，用于跨语言调函数，详见
https://en.wikipedia.org/wiki/Foreign_function_interface

** DONE VASP 收敛性测试的小脚本 :@PhysicalChemistry:VASP:Shell:ASE:
CLOSED: [2021-04-16 Fri 20:57]
:PROPERTIES:
:EXPORT_FILE_NAME: vasp-convergence-test-scripts
:EXPORT_DATE: [2021-04-16]
:END:

一般而言，在使用 VASP 计算体系之前都需要对一些参数做收敛性测试，侯老师[fn:: https://github.com/orivenlikon/vaspDoc/blob/master/%5Bmuchong.com%5Dvasp入门指南-复旦-侯柱峰.pdf]
曾写过一本VASP 入门手册，里面给了一些测试计算参数的小脚本，这里我
也给出一些我经常用的收敛性测试脚本，权当抛砖引玉了。

#+hugo: more

本文提供的测试脚本可以写进提交任务的脚本中，进而充分利用超算上多核、多节点的计算
资源。需要注意的是，这些脚本本身并不产生 VASP 的输入文件，而是在已有的文件基础上
进行修改。

*** =SIGMA= 的测试
和上面的使用前提一样， INCAR 应提前准备好。 SIGMA 收敛的标准通常是 dE 绝对值小于
1.0meV/atom 。

#+begin_src sh
#!/bin/bash
#SBATCH xx
...

set -e
set -o pipefail

VASP_EXEC="srun /path/to/vasp"  # "mpirun -np xxx" is also ok

date >> sigma.txt
for i in 0.8 0.5 0.3 0.1 0.08 0.05 ; do
    echo
    sed -i "s/^.*\\bSIGMA\\b.*$/        SIGMA = $i" INCAR
    eval ${VASP_EXEC}
    TS=$(grep "EENTRO" OUTCAR | tail -1 | awk '{print $5}')
    echo "$i    $TS" >> sigma.txt
done

echo "NIONS = " $(grep NIONS OUTCAR | awk '{print $12}') >> sigma.txt
#+end_src

*** =ENCUT= 的测试
使用前请先写好一个 INCAR ，并确保里面包含 =ENCUT= 字段，且 =ENCUT= 单独占一行
（否则同一行内的其它参数会被舍去）。通常而言，达到收敛的标志是相邻两次迭代的能量
小于 1.0meV/atom 。

#+begin_src sh
#!/bin/bash
#SBATCH xx
...

set -e
set -o pipefail

VASP_EXEC="srun /path/to/vasp"  # "mpirun -np xxx" is also ok

date >> encut.txt
for i in {200..500..50}; do
    sed -i "s/^.*\\bENCUT\\b.*$/        ENCUT = $i" INCAR
    eval ${VASP_EXEC}
    E=$(grep TOTEN OUTCAR | tail -1 | awk '{printf "%12.6f", $5}')  # Extract TOTEN from OUTCAR
    echo "$i    $E" >> encut.txt
done

echo "NIONS = " $(grep NIONS OUTCAR | awk '{print $12}') >> encut.txt
#+end_src

*** 晶格参数的测试
**** 晶格常数的测试

执行这个测试需要准备好 POSCAR ，这个测试不依赖 ASE 等包，因为它实质上是在更改
POSCAR 第二行的 scale factor 。这个测试只是相对粗糙的测试，因此这里就直接在原位
覆盖前一次的计算结果了。

#+begin_src sh
#!/bin/bash
#SBATCH xx
...

set -e
set -o pipefail

VASP_EXEC="srun /path/to/vasp"  # "mpirun -np xxx" is also ok

date >> a.txt
for i in $(seq 0.99 0.001 1.01)
do
  sed -i "2c $i" POSCAR
  echo -e "a = $i angstrom"
  eval ${VASP_EXEC}
  E=`grep "TOTEN" OUTCAR | tail -1 | awk '{printf "%12.6f", $5 }'`
  V=`grep "volume" OUTCAR | tail -1 | awk '{printf "%12.4f", $5}'`
  printf "a = %6.3f Vol = %10.4f Energy = %18.10f\n" $i $V $E >> a.txt
  tail -1 a.txt
done
echo -e "\n\n" >> a.txt#+end_src
#+end_src

**** 晶格长度的测试
在测试晶格的角度、长度时就不得不使用其它包了，Python 的 ASE 包提供了相对完善的基
础设施，这里在使用它来辅助完成晶格测试的工作。另外，在测试 Slab 的真空层厚度时也
可以使用这个脚本[fn:: 这个脚本要求晶格的 c 轴垂直于 a 轴和 b 轴]。

#+begin_src python
#!/usr/bin/env python3

import os
from ase.io import read as poscar_reader

poscar = poscar_reader("POSCAR")
cell = poscar.get_cell().copy()

for i in range(1, 7):
    cell[-1, -1] += 5.0             # Increase length along z axis by 5 angstroms each time
    poscar.set_cell(cell)
    dirname = "{:02}".format(i*5)
    if not os.path.exists(dirname):
        os.mkdir(dirname)           # create directories for each test
    poscar.write(dirname + "/POSCAR", vasp5=True, direct=True)
    for infile in ['INCAR', 'POTCAR', 'KPOINTS', 'sub_vasp_tahoma']:
        abspath = os.path.abspath(infile)
        os.symlink(abspath, dirname + "/" + infile)
        pass
    print("POSCAR saved in {}".format(dirname + "/POSCAR"))
    pass
#+end_src

用户可以根据自己需要随意更改晶格的参数，具体的需求可以通过阅读 ASE 的文档[fn::
https://wiki.fysik.dtu.dk/ase/ase/atoms.html 和
https://wiki.fysik.dtu.dk/ase/ase/geometry.html]来实现，这里就不一一列举了。

*** Slab 衬底层数的测试
一般而言，结构建模都是在 Materials Studio 上完成的（我现在也是如此），但如果有对
Slab 衬底做收敛性测试的需求，还是要借助一下 ASE ，它也内置一了些常见的 Slab 。

下面是一个生成不同层数 Ag(111) Slab 的脚本：

#+begin_src python
#!/usr/bin/env python3

import os
import numpy as np
from ase.build import fcc111
from ase.constraints import FixAtoms

for i in np.arange(1, 9):
    numstr = str(i)

    # generate 1x1 slab along a and b axis, this slab has `i` layers
    # vacuum is 20 angstrom
    slab = fcc111("Ag", size=(1, 1, i), vacuum=20)

    # Relax the first 2 layers and fix the others.
    c = FixAtoms(mask=[atom.tag > 2 for atom in slab])

    # Apply the constraint
    slab.set_constraint(c)
    print(slab)
    if not os.path.exists(numstr):
        os.makedirs(numstr+"/opt")
        os.makedirs(numstr+"/band")
        pass
    slab.write(numstr+"/opt/POSCAR", vasp5=True, direct=True)
    pass
#+end_src

对于其它金属， ASE 也有支持，详细说明请看它的文档[fn::
https://wiki.fysik.dtu.dk/ase/ase/build/build.html]。

** DONE VASP 偶极校正及功函数的计算 :@PhysicalChemistry:VASP:Python:ASE:DipoleCorrection:Workfunction:
CLOSED: [2021-04-23 Fri 16:44]
:PROPERTIES:
:EXPORT_FILE_NAME: vasp-dipol-correction-work-function
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :katex true :markup goldmark
:EXPORT_DATE: [2021-04-23]
:END:

水文一篇，介绍了如何用 VASP 添加偶极校正参数、计算 Slab 体系的功函数，以及如何找
真空能级。

#+hugo: more

*** 概念解释
**** 功函数
将一个固体内部的电子移动到真空所需的能量。（类似于光电效应方程中的逸出功）。

**** 真空能级
固体表面外真空中自由电子所具有的能量。换句话说，电子跑出固体表面并达到这个能级后
即可认为它自由 +免费+ 了。

**** 偶极校正
因 VASP 所适用的体系是周期性体系，使用它来模拟实验中的 Slab 模型时会取一个相当大
的真空层来隔绝相信两个周期中 Slab 的相互作用。理想情况下，真空层中的功函数应当是
一条水平的直线（函数值为定值）。但如果表面的两侧并非对称，即其中一侧吸附了分子时，
这两侧的功函数存在差异，此时如果不进行偶极校正，真空中的功函数会是一条斜线；而经
过偶极校正后，功函数会出现一个阶梯，阶梯两侧附近的曲接近水平。下图[fn:5]是一个例
子。

#+CAPTION:  DFT 曲线为未经过偶极校正的功函数， DFT-DC 曲线是经过偶极校正后的功函数
#+NAME: fig:DFT-DC1
[[./vasp-dipol-correction-work-function/VCL-2.png]]


*** 如何计算
**** 偶极校正
VASP 中直接使用 =LDIPOL= 和 =IDPOL= 即可开启它的偶极校正功能。

- =LDIPOL = .TRUE.= 表示打开偶极校正；
- =IDIPOL = 3= 表示偶极校正所修正的方向为第 3 个晶格矢量方向对应的方向，一般来说就是 \(z\) 轴；
- =DIPOL = <3 float values>= 表示体系的中心，以分数坐标表示；

上面几个 Flag 中一般来说 DIPOL 不用填，因为 VASP 手册中[fn:4]有一句
#+begin_quote
If the flag is not set, VASP determines, where the charge density averaged over
one plane drops to a minimum and calculates the center of the charge
distribution by adding half of the lattice vector perpendicular to the plane
where the charge density has a minimum (this is a rather reliable approach for
orthorhombic cells).
#+end_quote
不过有时不填它会导致体系 *非常* 难以收敛，如果遇到这各情况，最好还是手动算一下所
有原子 \(z\) 坐标的平均值，然后 =DIPOL = 0.5 0.5 <averaged z>= ，此时修正效果可
能并不好，读者需要：

1. 打开偶极校正和 =DIPOL = 0.5 0.5 <averaged z>= ，并弛豫结构到稳定；
2. 关闭 =DIPOL= ，并弛豫到结构稳定；
3. 关闭 =DIPOL= ，打开 =LVHAR = .TRUE.= ，并做静态计算，得到功函数；

偶极校正的标准是功函数出现台阶，并且台阶两边为水平，如果画出的功函数图不是这样，
就要考虑调整参数了。

**** 功函数
在 VASP 中 =LVHAR= [fn:1]参数可以使 VASP 输出体系的功函数文件 =LOCPOT= 。LOCPOT
文件本身是 Volumetric data ，它的格式与 CHGCAR 一样[fn:2]。一般而言，用户关心的
功函数是垂直于表面方向上的数据，因此在得到 LOCPOT 后需要对它做一点工作，即对 \(xy\)
平面内的数据做平均，然后乘以晶胞的体积，就得到我们需要的功函数信息。这里给出一个
脚本[fn:3]来完成这项工作：

#+INCLUDE: "./vasp-dipol-correction-work-function/plot-workfunc.py" src python :lines "26-71"

完整的脚本文件已经放 Gist[fn:3] 上，当然你也可以直接点击[[file:vasp-dipol-correction-work-function/plot-workfunc.py][它]]来下载。运行这个脚本后
得到的 Workfunction.pdf 和 locpot.dat 就是 \(z\) 方向上的功函数信息。

#+CAPTION: Workfunction.png 示例
#+NAME: fig:Workfunction
[[./vasp-dipol-correction-work-function/Workfunction.png]]


*** 真空能级
前面已经提到，真空能级可以读取 locpot.dat 真空部分的数据得到，其实当你打开
=LVHAR= 时，它也可以通过读取 OUTCAR 得到，比如

#+begin_src sh
$ grep vacuum OUTCAR
 vacuum level on the upper side and lower side of the slab         2.807         3.188
#+end_src

这里的 upper side vacuum level 是指 Slab 上表面的真空能级（图 [[fig:Workfunction]]
中 30A 处的平台）， lower side vacuum level 自然就是下表面的真空能级了
（图 [[fig:Workfunction]] 中 35A 处的平台）。

需要注意的是，从 OUTCAR 中 grep 出的真空能级没有经过费米能级修正，它需要减去
OUTCAR 中的 E-fermi 才是实验中测得的功函数的值。所幸的是 plot-workfunc.py 已经
做了这个工作，用 locpot.dat 画出来的图就对应实验所测结果。

[fn:1] 在 VASP 5.2.12 之前的版本中 =LVTOT= 输出的文件是静电势的贡献；但在 VASP
5.2.12 及之后的版本中，交换关联势的贡献也会被写入 =LOCPOT= 中， =LVHAR= 输出的部
分才是真正静电势的贡献，也就是我们想要的部分；
[fn:2] CHGCAR 的格式请见 VASP 手册 https://www.vasp.at/wiki/index.php/CHGCAR ；
[fn:3] 完整脚本见 https://gist.github.com/Ionizing/1ac92f98e8b00a1cf6f16bd57694ff03 。
[fn:4] https://www.vasp.at/wiki/index.php/DIPOL
[fn:5] 图源： http://exciting-code.org/nitrogen-dipole-correction

** TODO 组内集群折腾实录
** DONE 镜像态的那些坑 :@PhysicalChemistry:VASP:IPS:ImagePotentialStates:
CLOSED: [2021-05-06 Thu 00:18]
:PROPERTIES:
:EXPORT_FILE_NAME: issues-with-ips
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :katex true :markup goldmark
:EXPORT_DATE: [2021-05-06]
:END:

本文是帮实验组计算表面态与镜像态相关性质时所遇到一些坑的总结。

#+hugo: more

#+begin_quote
限于 DFT 理论上的缺陷（使用指数函数逼近库仑势，从而加速收敛）， DFT 并不能算准
IPS 的能级（误差在 \(\pm 0.3eV\)左右），但有的实验又需要从 DFT 计算获得一些关于
IPS 的信息，于是即使 DFT 不能算准，也无大碍。在这个过程中本人似乎不止一次掉入坑
中，于是把这个过程记录下来，即便对后人没什么帮助，也算是对自己学习印迹的一丝收藏
吧。
#+end_quote

*** 表面态与镜像态
**** 表面态(Surface States, SS)
顾名思义，表面态就是在物体 *表面* 附近存在的电子态[fn:1]。表面意味着边界的存在，
边界外是真空，边界内是原子。正因为存在从体相到真空的剧烈变化，表面的原子存在不饱
和键，即悬挂键。这些悬挂键由那些在体相内本应成键的电子贡献，受这些电子影响，物体
的 *表面* 会出现一些新的、相对弥散的电子态，这些电子态被称为表面态。

**** 镜像态(Image Potential States, IPS)
将一个电荷放在无限大的导体表面（这里假设表面是平面），导体内部会发生极化，导致内
部电荷重新分布，从而产生一个静电势。这个静电势等效于导体内一个带相反电性的镜像电
荷产生的静电势，因而被称为镜像势。电子因镜像势会在导体表面 *外* 形成一些相对弥散
的态，这些态就是镜像态。

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./issues-with-ips/ips1.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 800 :iminoptions -density 720
#+begin_src latex
\scalebox{2.0}{
    \begin{tikzpicture}[thick]
        \def\z{3}
        \def\ze{\z/4*3}

        %% Medias
        \fill[blue!50,opacity=.3] (-\z-1/2,2) rectangle (0, -0.5);

        \node at (-1,1.5) {$\epsilon_r$};
        \node at (1,1.5) {$\epsilon_0$};

        \node at (-1,0.5) {Conductor};
        \node at (1,0.5) {Vacuum};

        %% Axes
        \node at (0,0) [below left] {$O$};
        \draw[-stealth] (-\z-1/2,0) -- (\z+1/2,0);
        \draw[thick,dashed] (0,-0.5) -- (0,2);

        %% Define two charges
        \node[fill=black!40,circle,label=above right:$e$]  (e) at  (\ze,1) {$-$};
        \node[fill=black!30,circle,label=above left:$-\beta e$] (be) at (-\ze,1) {$+$};

        %% Connect two nodes
        \draw[dashed,thin,gray] (be) -- (e);

        %% vertical line to z-axis
        \node (ex) at (\ze,0) [below] {$z$};
        \node (bex) at (-\ze,0) [below] {$-z$};
        \draw[thin,dashed] (ex) -- (e);
        \draw[thin,dashed] (bex) -- (be);
    \end{tikzpicture}
}
#+end_src

#+caption: 镜像电荷示意图， 0+ 侧是真空， 0- 侧是相对介电常数为 epsilon_r 的导体内部
#+RESULTS:
[[file:./issues-with-ips/ips1.svg]]

镜像势的势能曲线是反比例曲线：

\[ V(z) = - \frac{\beta e^2}{4\pi \epsilon_{0} \cdot 4z} \]

上式中 \(\beta = \displaystyle\frac{\epsilon_r-1}{\epsilon_r+1}\)

所以电子满足方程：

\[ \begin{aligned}
\frac{\hbar^2}{2m_e} \nabla^2 \Psi + V(z)\Psi &={} E\Psi \newline
\frac{\hbar^2}{2m_e} \nabla^2 \Psi - \frac{\beta e^2}{4\pi \epsilon_{0} \cdot 4z} \Psi &={} E\Psi
\end{aligned} \]

这个方程看起来很眼熟，它十分类似于氢原子 Schrodinger 方程。由于这个电子只在
\(z\) 方向上受镜像电荷作用，因而在 \(xy\) 方向上是自由的，所以它能量可以通过求解
一维氢原子 Schrodinger 方程得到：

\[ E_n = -\frac{0.85}{n^2}\frac{(\epsilon_r-1)^2}{(\epsilon_r+1)^2} \quad \text{eV} \]

其中 \(n\) 是主量子数，分子 0.85eV 正好是氢原子基态能量的 \(\dfrac{1}{4^2}\) 。
所以镜像态也可以根据主量子数的不同来区分出不同的能级。求解过程可以在一篇文章[fn:7]中查
到；镜像势的表达式的推导过程详见附录。

严格地说，镜像态也是表面态的一种[fn:2]。一般而言，镜像态在真空能级以下 1eV 以内，
DFT 算出的 IPS 能级可能会超过真空能级，但在实际上是不太可能的，即使真的有，实验
上也不大能测得到。

*** 计算过程
事实上计算出镜像态，并不需要改太多的东西。下面在介绍如何设置计算参数的同时以
Ag(111) 上吸附苯分子为例阐述如何从结果中分析是否存在 IPS 。

**** 计算参数

这里使用的晶格是 Ag(111) 的 \(3\times3\) 表面，上表面放置了一个苯分子，结构如图：

#+caption: Benzene on Ag(111)
[[./issues-with-ips/AgBenzene-structure.png]]

***** 足够的空带
如果体系比较小， VASP 默认取的 =NBANDS= 是足够找到 IPS 的；但当体系特别大的时候，
默认的 =NBANDS= 可能不太会覆盖到 IPS ，这时需要增加 =NBANDS= ，一般加到真空能级
以上 3eV 就足够了，实际上这里只是需要 VASP 能较为 /精确/ 地算对真空能级附近的态，
而标号接近 NBANDS 的能带不准确，表现在能带图上就是色散关系就像被生生截断了一样，
且呈锯齿状；此外，如果在实空间展开这个态会发现这个它像是随机生成的一样，没用使用
价值分布。关于真空能级怎么算，详见之前的博文。

这里使用的体系里因为原子数比较适中，不用额外增加 =NBANDS= 。

***** 足够的真空层
镜像态在真空层中，因此需要足够的真空层来容纳它，一般而言 30A 真空层可能还不算够。
但要注意 VASP 在算高度超过 70A 的晶格时会很难收敛。

这里使用的体系加了 50A 的真空层，已经足够放下上表面的 IPS 。

***** 偶极校正
如果 Slab 表面没有吸附其它原子/分子，则不必对体系进行偶极校正，否则需要校正，具
体过程参见之前的博文。

偶极校正效果如图：
#+caption: Benzene on Ag111 偶极校正后功函数图像
[[./issues-with-ips/AgBenzene-workfunc.png]]

**** 验证计算结果
这里的「验证」与其说是验证，不如说是寻找。前面提到， IPS 是一种相对「弥散」的态，
它「弥散」的性质决定了怎么去 Identify IPS 。这里总结了几种「找」 IPS 的方法。

***** PDOS 法
一个态比较「弥散」说明它的局域性（locality）比较低，反映在物理图像里就是它投影在
原子上的态比较少。因此我们可以在通过不同能带在原子上的投影大小来判断它是否是 IPS。

幸运地是 VASP 可以通过 =LORBIT = .TRUE.= 来输出 =PROCAR= 文件，它包含了每个能带
在所有原子上的投影大小，顺便说一句， =PROCAR= 还包含不同角动量的投影大小。

先结构弛豫，再进行自恰计算得到 =PROCAR= 后，可以通过以下方法查看这个态在所有原子
上的投影之和：

打开 =PROCAR= ，定位到真空能级 [fn:3] 附近 \(\Gamma\) 点的能带
    #+begin_src
band    35 # energy    3.23957699 # occ.  0.00000000

ion      s     py     pz     px    dxy    dyz    dz2    dxz  x2-y2    tot
    1  0.002  0.000  0.000  0.000  0.000  0.000  0.002  0.000  0.000  0.004
    2  0.001  0.000  0.001  0.000  0.000  0.000  0.000  0.000  0.000  0.002
    ......
tot    0.005  0.000  0.004  0.000  0.000  0.000  0.004  0.000  0.000  0.013
#+end_src
看最后一行 =tot 0.005 ...= ，最右边也有一个 =tot= ，两者交叉的的值 =0.013= 即为
这条能带在整个系统上的投影大小，换言之，局域度的大小。那么这个值越小则它是 IPS
的可能性越高。比如上面的能带 PDOS 中整体的 PDOS 之和只有 0.013 ，说明它的局域度
很小，那么这个态非常弥散，有可能是 IPS 。

***** 实空间分布法
仅仅是通过能带的 PDOS 还不足以确认这条带是不是 IPS ，有些费米能级附近的带总体
PDOS 也很小，但不是 IPS 。这时就需要其它方法来看了，比如本节要介绍的实空间分布法。

IPS 在实空间的分布特征相当明显：
1. 它们在表面以外，并且随着主量子数的升高有着对应个数的波包；
2. 每个波包对应的空间分布呈明显的近自由电子态的特征。

如下图[fn:4]所示：

#+CAPTION: IPS 的实空间分布曲线，最下面的曲线是镜像势的曲线。
#+NAME: fig:ips-ref1
[[./issues-with-ips/ips_ref1.jpg]]

上面图中 \(n=1\) 的 IPS 只有一个波包， \(n=2\) 时有两个波包， \(n=3\) 时有三个，
以此类推下去……

对于第一个特征，我们可以对波函数的模平方作 \(z\) 方向上的分布，数出表面外有多少
个峰，注意区分 Slab 的上表面和下表面，只有上表面的波包应该被计入在内。

在 Benzene on Ag(111) 体系中，对应的 IPS 实空间分布曲线如下：

#+CAPTION: Benzene on Ag(111) 表面 IPS 的实空间分布曲线
#+NAME: fig:ips-AgBenzene-ips1
[[./issues-with-ips/AgBenzene-ips1.png]]

如果只看 \(z\) 方向上的波函数觉得不放心，可以把某条带在实空间的分布画出来，如果
它在真空中，并且上下表面近似为平面，即在水平方向上为近自由电子，也就可认为它是
IPS ，如下图所示：

#+caption: Benzene on Ag(111) 体系 IPS 的实空间分布，这里每张图的等值面 Level 不同，以体现出对应数量的波包
#+name: fig:ips-AgBenzene-realspace
[[./issues-with-ips/AgBenzene-ipsrealspace.png]]

实际上，图上所标 \(n=4\) 的曲线并不真的是 IPS ，它的能量在真空能级以上，并且它的
能量也不符合 \(\dfrac{1}{n^2}\) 的规律。如果仔细验证的话， \(n=1,2,3\) 的能量也
并不符合这个规律，这就是 DFT 理论的局限所致，想要再算得更准，需要更大的代价。

***** 能带法
以上是在单点能静态计算的基础上进行的分析，如果已经画出了这个体系的能带图，从能带
图上可以更加清晰地反映出 IPS 的特征。

能带图的横坐标量纲是动量，纵坐标是能量。一个自由电子的能量全部由动能贡献，因此它
的能量与动量的关系就是

\[ E = E_k = \frac{p^2}{2m} = \frac{g^2}{2m_e} \]

\(E\) 与 \(g\) 呈二次函数式色散关系，那么只要某个带的色散关系与抛物线相似，就有
理由认为某能带可能是 IPS ，比如下面的图中 4 eV 附近 \(\Gamma\) 点的能带明显呈抛
物线色散关系，而它们也确实算是 IPS 。

[[./issues-with-ips/AgBenzene-band.png]]

如果更有耐心的话，可以算一下那几条带的相对有效质量，如果接近 1 ，就可以很明确地
说明这几条带是 IPS ，可惜本人不太想再算这个（实际就是懒），这个就算作「读者自证
不难」吧2333。
*** 附录
**** 镜像势表达式的推导
这里更一般地推导一下两种介质界面处镜像势的表达式，过程参考自[fn:6]。

假设有两种介质 1 和 2，它们的介电常数分别为 \(\epsilon_1\) 和 \(\epsilon_2\) ，有电荷
\(q\) 在介质 1 中，如下图所示：

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./issues-with-ips/ips2.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 800 :iminoptions -density 720
#+begin_src latex
\scalebox{2.0}{
    \begin{tikzpicture}[thick]
        \def\z{3}
        \def\ze{\z/4*3}

        %% Medias
        \fill[blue!50,opacity=.3] (-\z-1/2,2) rectangle (0, -0.5);
        \node at ( 3,1.5) {$\epsilon_1$};
        \node at (-3,1.5) {$\epsilon_2$};

        %% Axis
        \node at (0,0) [below left] {$O$};
        \draw[thick,-stealth] (-\z-1/2,0) -- (\z+1/2,0);
        \draw[thin,dashed] (0, -0.5) -- (0,2);

        %% Charges
        \node[label=above right:$q$] (e1) at ( \ze,0) {};
        % \node[label=above left:$\beta q$] (e2) at (-\ze,0) {};
        \fill[black] (e1) circle (0.07);
        % \fill[black] (e2) circle (0.07);

    \end{tikzpicture}
}
#+end_src

#+RESULTS:
[[file:./issues-with-ips/ips2.svg]]

现在将问题分成两部分来看：分别计算介质 1 和介质 2 中电场强度。

在介质 1 中任取一点 \(P\) ，同时认为 \(q\) 的镜像电荷等效带电量为 \(q'\) ，则
\(P\) 点的受力如下图所示

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./issues-with-ips/ips3.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 800 :iminoptions -density 720
#+begin_src latex
\scalebox{2.0}{
    \begin{tikzpicture}[thick,>=stealth]
        \def\z{3}
        \def\ze{\z/4*3}

        %% Medias
        % \fill[blue!50,opacity=.3] (-\z-1/2,2) rectangle (0, -0.5);
        \node at ( 3,1.5) {$\epsilon_1$};
        \node at (-3,1.5) {$\epsilon_1$};

        %% Axis
        \node at (0,0) [above left] {$O$};
        \draw[thick,->] (-\z-1/2,0) -- (\z+1/2,0) node [above left] {$z$};
        \draw[thin,dashed] (0, -0.5) -- (0,2);

        %% Charges
        \node[label=above:$q$] (e1) at ( \ze,0) {};
        \node[label=above:$q'$] (e2) at (-\ze,0) {};
        \fill[black] (e1) circle (0.05);
        \fill[black] (e2) circle (0.05);

        \draw (\ze, -0.1) -- (\ze, -0.3);
        \draw (-\ze, -0.1) -- (-\ze, -0.3);

        \draw[<->] (-\ze,-0.2) -- node[below] {$d$} (0,-0.2);
        \draw[<->] (\ze,-0.2) -- node[below] {$d$} (0,-0.2);
        \draw[<->] (0, 0.2) -- node[above] {$z$} (1,0.2);

        %% P point
        \node[label=above:$P$] (p) at (1,1.5) {};
        \fill[black] (p) circle (0.05);
        \draw[dashed] (p) -- node[above right] {$R_1$} (e1);
        \draw[dashed] (p) -- node[above left] {$R_2$} (e2);

        \draw[dashed] (p) -- node[right]{$r$} (1,0);
        \draw (1,0.15) -| (1.15,0);
    \end{tikzpicture}
}
#+end_src

#+RESULTS:
[[file:./issues-with-ips/ips3.svg]]

此处的电场强度为

\[\begin{aligned}
V_1 &={} \frac{1}{4\pi \epsilon_1} \left( \frac{q}{R_1} + \frac{q'}{R_2} \right) \newline
R_1 &={} \sqrt{(z-d)^2 + r^2} \newline
R_2 &={} \sqrt{(z+d)^2 + r^2} \newline
E_z &={} -\frac{\partial V_1}{\partial z} = \frac{1}{4\pi\epsilon_1}
        \left[ \frac{q(z-d)}{R_1^3} + \frac{q'(z-d)}{R_2^3} \right] \newline
E_r &={} -\frac{\partial V_1}{\partial r} = \frac{1}{4\pi\epsilon_1}
        \left[ \frac{qr}{R_1^3} + \frac{q' r}{R_2^3} \right] \newline
\end{aligned}\]

现在考虑介质 2 中的电场强度，由于经过一个介面，介电常数分布发生了改变，所以在介
质 2 中所感受到的原来电荷的等效电荷为 \(q''\) 。

#+header: :headers '("\\usepackage{tikz}")
#+header: :results file graphics :file ./issues-with-ips/ips4.svg
#+header: :exports results
#+header: :fit yes :imoutoptions -geometry 800 :iminoptions -density 720
#+begin_src latex
\scalebox{2.0}{
    \begin{tikzpicture}[thick,>=stealth]
        \def\z{3}
        \def\ze{\z/4*3}

        %% Medias
        \fill[blue!50,opacity=.3] (-\z-1/2,2) rectangle (\z+1/2, -0.6);
        \node at ( 3,1.5) {$\epsilon_2$};
        \node at (-3,1.5) {$\epsilon_2$};

        %% Axis
        \node at (0,0) [above right] {$O$};
        \draw[thick,->] (-\z-1/2,0) -- (\z+1/2,0) node [above left] {$z$};
        \draw[thin,dashed] (0, -0.5) -- (0,2);

        %% Charge q''
        \node[label=above:$q''$] (e3) at (\ze,0);
        \fill[black] (e3) circle (0.05);

        \draw (\ze, -0.1) -- (\ze, -0.3);
        \draw[<->] (\ze, -0.2) -- node[below] {$d$} (0,-0.2);

        %% P point
        \node[label=left:$P$] (p) at (-1,1.5);
        \fill[black] (p) circle (0.05);
        \draw[dashed] (p) -- node[above right] {$R_3$} (e3);
        \draw[dashed] (p) -- node[right] {$r$} (-1,0);
        \draw (-1,0.15) -| (-0.85,0);

        \draw (-1,-0.1) -- (-1,-0.3);
        \draw[<->] (-1,-0.2) -- node[below] {$z$} (0,-0.2);
    \end{tikzpicture}
}
#+end_src

#+RESULTS:
[[file:./issues-with-ips/ips4.svg]]

P 点的电场强度可以计算出来：

\[\begin{aligned}
V_2 &={} \frac{1}{4\pi\epsilon_2} \frac{q''}{R_3} \newline
R_3 &={} \sqrt{(z-d)^2 + r^2} \newline
E_z^{(2)} &={} -\frac{\partial V_2}{\partial z} =
                \frac{1}{4\pi\epsilon_2} \frac{q'' (z-d)}{R_3^3} \newline
E_r^{(2)} &={} -\frac{\partial V_2}{\partial r} =
                \frac{1}{4\pi\epsilon_2} \frac{q'' r}{R_3^3} \newline
\end{aligned}\]


在界面处应用导体介质界面上的边界条件：

\[\begin{cases}
z = 0 \implies R_1 = R_2 = R_3 = R \newline
D_z^{(1)} = D_z^{(2)} \newline
E_r^{(1)} = E_r^{(2)} \newline
\end{cases}\]

即：

\[\begin{aligned}
\epsilon_1 E_z^{(1)} & = {} \epsilon_2 E_z^{(2)} \newline
\implies \epsilon_1 \frac{1}{4\pi\epsilon_1} \frac{(q-q')d}{R^3} & = {}
         \epsilon_2 \frac{1}{4\pi\epsilon_2} \frac{q'' d}{R^3} \newline
\implies q - q' &={} q''
\end{aligned}\]

\[\begin{aligned}
E_r^{(1)} &={} E_r^{(2)} \newline
\implies \frac{1}{4\pi\epsilon_1} \frac{(q+q')r}{R^3} &={}
         \frac{1}{4\pi\epsilon_2} \frac{q'' r}{R^2} \newline
\implies \frac{q+q'}{\epsilon_1} &={} \frac{q''}{\epsilon_2}
\end{aligned}\]

联立上面两式，可以得到

\[ q' = -\frac{\epsilon_2 - \epsilon_1}{\epsilon_2 + \epsilon_1} q \]

如果用相对介电常数 \(\epsilon_r = \dfrac{\epsilon_2}{\epsilon_1}\) ，上面式子还
能简化为

\[ q' = -\frac{\epsilon_r - 1}{\epsilon_r + 1} q = -\beta q \]

这就是前文中镜像电荷表达式中 \(\beta\) 的来源。可以看出，如果 \(\epsilon_r < 1\)
，镜像电荷的符号与原来电荷相同。

电荷 \(q\) 的受力以及势能表达式：

\[\begin{aligned}
F(z) &={} -\frac{\beta q^2}{4\pi \epsilon_0 (2z)^2} \quad \beta = \frac{\epsilon_r-1}{\epsilon_r+1} \newline
V(z) &={} -\frac{\beta q^2}{4\pi \epsilon_r \cdot 4z}
\end{aligned}\]

文中第一节的表达式得证。

[fn:1] Wikipedia Surface States item https://en.wikipedia.org/wiki/Surface_states
[fn:2] Image potential surface states
https://iopscience.iop.org/article/10.1088/0031-8949/36/4/009/pdf
[fn:3] 真空能级可以在 =OUTCAR= 里找到（ =grep vacuum OUTCAR= ）
[fn:4] 图片来自 Image-potential-induced states at metal surfaces https://www.sciencedirect.com/science/article/pii/S0368204802001500
[fn:5] 2PPE: Two-photon photoemission spectroscopy of image states. Photonic
Probes of Surfaces, P. Halevi, Ed. (Elsevier, Amsterdam, 1995), pp. 347-411
[fn:6] Classical Electrodynamics, From Image Charges to the Photon Mass and
Magnetic monopoles, Francesco Lacava https://www.springer.com/gp/book/9783319394732
[fn:7] One-dimensional hydrogen atom https://royalsocietypublishing.org/doi/10.1098/rspa.2015.0534
** TODO 二维 Ising Model 的 Julia 实现
** DONE 使用数值方法求解单电子 Schrodinger 方程 :@Physics:Julia:FiniteDifferenceMethod:FiniteElementMethod:SchrodingerEquation:NumercialMethod:
CLOSED: [2021-08-06 Fri 14:44]
:PROPERTIES:
:EXPORT_FILE_NAME: schrodinger-equation-numerical-methods
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :katex true :markup goldmark
:END:

经常有人觉得会解薛定谔方程会给人一种很厉害的感觉（尤其是对还没学过 QM QC 等课程中学生小朋友而言），
确实，现在能写出解析解的 Schrodinger 方程屈指可数；
而且仅仅增加粒子数量不考虑各种修正就足以使求解的难度上升一大截。
不过在这里我们不考虑多个粒子的情况，也不考虑什么相对论效应 blabla ，
我们只考虑一个电子在一个任意势场下的定态 Schrodinger 方程，
然后来用数值方法求解这个方程，得到电子的波函数并可视化，
顺便验证一下教材上各种电子轨道的分布图，体验一把亲手解 Schrodinger 方程的感觉。

#+hugo: more

这里本文是在实空间的笛卡尔坐标系进行求解。

*** 单粒子定态 Schrodinger 方程
考虑一个电子在势场 $V$ 中，它的定态 Schrodinger 方程是

\begin{equation}
    \hat{H} \Psi(x, y, z) = E\Psi(x, y, z)
\end{equation}

如果这个势场是 $V = 0$ ，并且限定这个电子在一个边长为 $a$ 的箱子内，此时 Schrodinger 方程就变成了

\begin{equation}
    -\frac{\hbar^2}{2m} \left( \frac{\partial^2}{\partial x^2} +
                                 \frac{\partial^2}{\partial y^2} +
                                 \frac{\partial^2}{\partial z^2} \right)
    \Psi(x, y, z) = E\Psi(x, y, z)
\end{equation}

这个方程可以写出解析解[fn:: https://en.wikipedia.org/wiki/Particle_in_a_box]
（参加过考试的同学应该能默写这个公式了）：

\[E = (n_x^2 + n_y^2 + n_z^2) \frac{h^2}{8ma^2}\]

\[ \begin{aligned}
    \Psi(x, y, z) &={} X(x)Y(y)Z(z) \newline
                  &={} \sqrt{\frac{8}{a^3}}\sin(\frac{n_x \pi x}{a})\sin(\frac{n_y \pi y}{a})\sin(\frac{n_z \pi z}{a})
\end{aligned} \]

这是三维情况下的解，如果体系只有一维，它的能级表达式是

\[
    E = \frac{n^2 h^2}{8ma^2} \newline
    \Psi(x) = \sqrt{\frac{2}{a}} \sin(\frac{n \pi x}{a})
\]

这是它们的解析解，也是我们后面验证结果正确性的参考。
以上结果的推导请参考任意一本《量子力学》或《量子化学》或者《结构化学》。

*** 有限差分法
所谓有限差分法，就是有限差分来近似导数，从而寻求微分方程近似解的方法。针对导数的
有限差分操作可以参考 [[https://en.wikipedia.org/wiki/Finite_difference_coefficient][Wikipedia]] [fn:: https://en.wikipedia.org/wiki/Finite_difference_coefficient]，
简单来说就是用各种近似方法来逼近导数的值。

假设存在一个离散的函数 $f(x), x = x_1, x_2, ... , x_n$ ，并且 $x_{i+1} - x_{i} = \Delta x$ 为一定值，
根据有限差分的推导，可以得到下面的结论：

**** 一阶导数的离散化
这里使用一种最为常见的离散化方法来近似一阶导数：

\begin{equation}
    f'(x_i) \approx \frac{f(x_i+\Delta x) - f(x_i - \Delta x)}{2\Delta x}
            = \frac{f(x_{i+1}) - f(x_{i-1})}{2\Delta x}
\end{equation}

再假设 $f(x)$ 可以写成一个列向量 $\ket{f} = \begin{bmatrix} f(x_1), f(x_2),
    \cdots, f(x_n) \end{bmatrix}^T$ ，那么一阶导数算符 $\dfrac{d}{dx}$ 可以写成

\[\frac{d}{dx}
\begin{bmatrix} f(x_1)\newline f(x_2) \newline \vdots \newline f(x_n) \end{bmatrix} =
\frac{1}{2\Delta x}
\begin{bmatrix}
    0 & 1 &   &  &   \newline
    -1 & 0 & 1 &  &   \newline
      & -1 & 0 & \ddots &   \newline
      &   & \ddots & \ddots  & 1 \newline
      &   &   & -1 & 0
\end{bmatrix} \cdot
\begin{bmatrix} f(x_1)\newline f(x_2) \newline \vdots \newline f(x_n) \end{bmatrix} \]

这是在没有处理边界条件的情况下的一阶导数算符，
如果考虑周期性边界条件，上式矩阵的左下角和右上角分别为 1 和 -1  。
此外这种方法近似得到的一阶导的精度是 $O((\Delta x)^2)$ ，
更高阶的近似及其它非对称的方法请参考本节之前提到的 Wikipedia 。

**** 二阶导数的离散化
比较常见的二阶导数离散化方法如下：

\begin{equation}\begin{aligned}
    f'(x_i+\frac{1}{2} \Delta x) &\approx{} \frac{f(x_i + \Delta x) - f(x_i)}{\Delta x}
            = \frac{f(x_{i+1}) - f(x_i)}{\Delta x} \newline
    f'(x_i-\frac{1}{2} \Delta x) &\approx{} \frac{f(x_i) - f(x_i - \Delta x)}{\Delta x}
            = \frac{f(x_i) - f(x_{i-1})}{\Delta x} \newline
    f''(x_i) &\approx{} \frac{ f'(x_i+\frac{1}{2} \Delta x) - f'(x_i-\frac{1}{2} \Delta x) }{\Delta x} \newline
             &={} \frac{ f(x_{i+1}) + f(x_{i-1}) - 2f(x_i) }{(\Delta x)^2}
\end{aligned}\end{equation}

同样，它也可以用矩阵的形式表达出来：

\[ \frac{d^2}{dx^2}
\begin{bmatrix} f(x_1)\newline f(x_2) \newline \vdots \newline f(x_n) \end{bmatrix} =
\frac{1}{(\Delta x)^2}
\begin{bmatrix}
    -2 & 1 &   &  &   \newline
     1 & -2 & 1 &  &   \newline
      & 1 & -2 & \ddots &   \newline
      &   & \ddots & \ddots  & 1 \newline
      &   &   & 1 & -2
\end{bmatrix} \cdot
\begin{bmatrix} f(x_1)\newline f(x_2) \newline \vdots \newline f(x_n) \end{bmatrix} \]

如果需要考虑周期性边界条件，矩阵的左下角和右上角都应为 1 。
这种方法近似的精度是 $O((\Delta x)^2)$ 。

**** 一维系统 Hamiltonian 的构造及求解
***** 一维势箱模型系统的求解

Hamiltonian 的整体表达式为

\[ H = T + V \]

如果系统只有一维，那么 Hamiltonian 很好构造，直接在 $T$ 的基础上加上势能即可

\[H = \frac{1}{(\Delta x)^2}
\begin{bmatrix}
    -2 & 1 &   &  &   \newline
     1 & -2 & 1 &  &   \newline
      & 1 & -2 & \ddots &   \newline
      &   & \ddots & \ddots  & 1 \newline
      &   &   & 1 & -2
\end{bmatrix} +
\begin{bmatrix}
V_1 & & & \newline
& V_2 & & \newline
& & \ddots & \newline
& & & V_n
\end{bmatrix} \]

然后我们的问题就变成了

\[
H \ket{\psi} = E\ket{\psi}
\]

这是一个典型的本征值问题，只要对 $H$ 进行对角化就可以得到我们想到的能量 $E$ 和波函数 $\ket{\psi}$ 。
下面是它的程序实现（本文使用 Julia 作为有限差分法的实现语言）

#+begin_src julia :results output :session *julia* :exports both
#!/usr/bin/env julia

using LinearAlgebra;
using SparseArrays;
using Arpack;
using Plots;

################################################################################
#
#                           Constants Part
#
################################################################################

const N = 5000;                 # sample points
const len = 1.0;                # box length

const k = 3.8099821161548593;   # hbar^2 / (2*m_e) = (Å^2) / eV
const m = 1.0;                  # relative mass of electron

const nev = 4;                  # number of eigen values to be covered

x = LinRange(0.0, len, N);
const dx = len / N;

################################################################################
#
#                           Hamiltonian Part
#
################################################################################

T_ = sparse(-2.0I, N, N);
T_[diagind(T_,  1)] .= 1.0;
T_[diagind(T_, -1)] .= 1.0;
T_ *= -k / (m * dx * dx);

T = deepcopy(T_);
H = T;

println("Hamiltonian constructed, start solving ...");
@time λ, ϕ = eigs(H, nev=nev, which=:LM, sigma=0.0);
@show λ

################################################################################
#
#                           Hamiltonian Part
#
################################################################################

for i in 1:nev
    ϕ[:,i] ./= norm(ϕ[:, i]) * sqrt(dx)   # Normalization
    @assert sum(ϕ[:, i].^2) * dx ≈ 1.0    # verify the norm: ∫ |ϕ|² dx == 1
end

@show maximum(ϕ[:, 1])

p = plot(x, ϕ, layout=(2, 2), size=(800, 600));
savefig(p, "./1D-particle-in-a-box-eigvec.svg");
#+end_src

#+RESULTS:
#+begin_example
Hamiltonian ready, start solving ...
  1.991257 seconds (7.25 M allocations: 439.625 MiB, 8.56% gc time, 99.53% compilation time)
λ = [37.58797833051402, 150.3518984879221, 338.29171597315013, 601.4073566198176]
maximum(ϕ[:, 1]) = 1.4140720924720651
#+end_example

下面我们来验证一下程序的结果：

程序中有 $k = \hbar^2 / 2m_e = 3.80998 (\mathrm{Å^2/eV})$ ，它把一些物理常数打包处理并化为原子单位制，
因此在和解析解对比时也要以此为准，此外程序中定义 $a=1Å$ ，没有显式处理边界条件。势箱模型中解析解为

\[
    E = \frac{n^2 h^2}{8ma^2} = \frac{\hbar^2}{2m} \cdot \frac{4\pi^2 n^2}{4a^2} = \frac{kn^2\pi^2}{a^2}
\]

代入 $k$ 和 $a$ ，得到 $E_1 = 37.6029953761$ ，与数值解 $\lambda_1=37.58797833051402$ 对比相当接近，
继续验证 $\lambda_2$ 、 $\lambda_3$ 等可以发现它们也符合 $n^2$ 的增长曲线（读者可自行验证）。

再来验证一下波函数：
[[./schrodinger-equation-numercial-methods/1D-particle-in-a-box-eigvec.svg]]

它显然符合正弦曲线的特征，并且在边界处为 0 ，最大值为 1.414072 与归一化因子 $\sqrt{2} = 1.414213$
相差也在允许范围内，因此现在可以放心地说，如果 $T$ 没有特殊边界条件处理，
它的边界条件就是使边界处的波函数为 0 ，这在后面的计算中可以得到进一步验证。

***** 带有 Chulkov 势的一维势箱系统求解

上面的系统中电子不受束缚， Hamiltonian 里没有势能这一项，这也就没有验证势能项加在对角线上的合理性，
下面我们使用一种于二十年前被提出的势能函数来验证这一点。

Chulkov [fn:: https://www.sciencedirect.com/science/article/pii/S0039602899006688]
等于 1997 年提出一种势能用于模拟出金属表面的镜像态。它以金属表面为 0 点， 0 以下使用正弦函数
模拟金属的体相内的势能， 0 及以上使用正弦及指数函数等模拟金属表面以外的镜像势，它有如下形式：

\[
    V_m(z) = \begin{cases}
        -A_{10} + A_1 \cos \left( \frac{2\pi}{d_m} z \right) & z \le 0 \newline
        -A_{20} + A_2 \cos(\beta z) & 0 < z \le z_1 \newline
        -A_3 \exp\left[-\alpha(z-z_1)\right]  & z_1 < z \le z_\mathrm{im} \newline
        \dfrac{\exp\left[ -\lambda (z-z_\mathrm{im}) \right]-1}{4(z-z_\mathrm{im})} & z > z_\mathrm{im}
    \end{cases}
\]

体现在图像上是这个样子的：

[[./schrodinger-equation-numercial-methods/1D-chulkov-pot.png]]

这里选择用于 Ag(111) 表面的各参数，代码如下：

#+begin_src julia
#!/usr/bin/env julia

# Reference: Image potential states on metal surfaces: binding energies and wave functions
#             https://www.sciencedirect.com/science/article/pii/S0039602899006688

using LinearAlgebra;
using SparseArrays;
using Arpack;
using Plots;


const N = 15000;
const len = 150.0;

const k = 3.8099821161548593    # hbar^2 / (2*m_e) /(Å^2) / eV
const k_c = 14.39964547842567   # (e*e / (4 * np.pi * epsilon_0))  # measured in eV / Å
const m = 1.0                   # mass of electron

const dx = len / N;

const nev = 8;

################################################################################
#
#                                Potential Part
#
################################################################################

#=
#
# V1(z) = -A10 + A1*cos(2pi*z/dm)    z <= 0
# V2(z) = -A20 + A2*cos(beta*z)      0 < z <= z1
# V3(z) = -A3 * exp(-alpha*(z-z1))   z1 < z <= zim
# V4(z) = (exp(-lambda*(z-zim))-1.0) / (4.0*(z-zim))  z > zim
#
=#

const a0 = 0.529;# A, bohr raidus
const as = 4.43; # a.u.
const A10 = 9.64;# eV
const A1 = 4.30; # eV
const A2 = 3.8442; # eV
const beta0 = 2.5649; # 1/a.u.
const zim0 = 2.35; # a.u.

const dm = as * a0; # A
const A20 = A10 + A2 - A1; # eV
const beta = beta0 / a0; # A^-1
const zim = zim0 * a0; # A
# const A3 = A2 / sqrt(2); # eV
const z1 = 5*pi/(4*beta); # A
const A3 = A20 - A2*cos(beta*z1); # eV
const alpha = - A2*beta*sin(beta * z1) / A3; # A^-1
const lambda = 4*A3*exp(-alpha*(zim - z1)) / k_c; # A^-1

@show A10 A1 dm A20 A2 beta A3 alpha z1 lambda zim

z = LinRange(-len/2, len/2, N);
V = similar(z);

@. V[z<=0]      = -A10 + A1 * cos(2pi * z[z<=0] / dm)
@. V[0<z<=z1]   = -A20 + A2 * cos(beta * z[0<z<=z1])
@. V[z1<z<=zim] = - A3 * exp(-alpha * (z[z1<z<=zim] - z1))
@. V[z>zim]     = (exp(-lambda * (z[z>zim] - zim)) - 1.0) / (4.0 * (z[z>zim] - zim)) * k_c

################################################################################
#
#                           Hamiltonian Part
#
################################################################################

Ident = sparse(1.0I, N, N);
T_ = sparse(-2.0I, N, N);
T_[diagind(T_,  1)] .= 1.0;
T_[diagind(T_, -1)] .= 1.0;
T_ *= -k / (m * dx * dx);

T = deepcopy(T_);

H = T;
H[diagind(H)] .+= V;
Vmin = -1.0;

λ, ϕ = eigs(H, nev=nev, which=:LM, sigma=min(0, Vmin));
@show λ

for i in 1:nev
    ϕ[:,i] ./= norm(ϕ[:,i]) * sqrt(dx)      # normalization
    @assert  sum(ϕ[:,i].^2) * dx ≈ 1.0      # test norm
end

p = plot(z, ϕ.^2, layout=(4,2), size=(800, 600));
savefig(p, "./1D-chulkov-eigvec.svg");
#+end_src

下面是计算结果与文献值对比

#+caption: 有限差分法计算 Chulkov 势结果与文献值对比
| λ | 计算结果(eV) | 文献值(eV) | 实验值(eV) |
|---+--------------+------------+------------|
| 1 |       -0.788 | −0.77      | -0.77      |
| 2 |       -0.674 | -          | -          |
| 3 |       -0.533 | -          | -          |
| 4 |       -0.330 | -          | -          |
| 5 |       -0.208 | -0.22      | -0.23      |
| 6 |       -0.103 | -0.095     | -0.10      |
| 7 |       -0.061 | -0.053     | -0.052     |
| 8 |       -0.031 | -          | -          |

上面表中有一些态主要分布在体相内，文献和实验中没有测到。为更明显地对比镜像态与 bulk 态的区别，
这里使用 $|\phi|^2$ 作图：

[[./schrodinger-equation-numercial-methods/1D-chulkov-eigvec.svg]]

显然， $\phi_2$ 、 $\phi_3$ 和 $\phi_4$ 大部分都处于体相内，从包络线的形状看，
它们类似于刚刚讨论过的势箱内的态，但这些态不属于镜像态，所以在与实验对比时应排除在外。
而 $\phi_1$ 、 $\phi_5$ 、 $\phi_6$ 和 $\phi_7$ 在真空中的部分存在波包，且波包的数量
刚好对应主量子数 $n$ ，如 $\phi_5$ 在 $x\ge 0$ 的部分有两个波包，它就是 $n=2$ 对应的本征态。

**** 二维及更高维系统的 Hamiltonian 构造与求解

一维情况下我们可以直接使用二阶导而无需其它处理即可构造出动能算符，但在更高维度下要如何构造动能算符，
以及 Hamiltonian 呢？

***** 高维 Laplacian 的离散化

根据 [[https://en.wikipedia.org/wiki/Kronecker_sum_of_discrete_Laplacians][Wikipedia]] [fn:: https://en.wikipedia.org/wiki/Kronecker%5Fsum%5Fof%5Fdiscrete%5FLaplacians]
上关于离散 Laplacian （拉普拉斯算符）的描述，多维离散 Laplacian 是一维离散 Laplacian
的 Kronecker Sum （克罗内克和）。

例如对于一个二维系统：

\[
    L = \bold{D}_\bold{xx} \oplus \bold{D}_\bold{yy} = \bold{D}_\bold{xx} \otimes \bold{I} + \bold{I} \otimes \bold{D}_\bold{yy}
\]

其中 $\bold{D}_\bold{xx}$ 、 $\bold{D}_\bold{yy}$ 表示在 $x$ 、 $y$ 方向上的 Laplacian 矩阵， $\bold{I}$ 是单位矩阵。

注意，上式中 "$\oplus$" 表示 Kronecker Sum 操作而不表示矩阵 Direct Sum （直和）操作，尽管它们所用的符号是一样的；
而 "$\otimes$" 则可以理解为 Kronecker Product 或者 Direct Product （直积）操作，因为在此处可以认为两种操作等价。

相应地，对于一个三维系统，它的 Laplacian 应该是

\[
    L = \bold{D}_\bold{xx} \otimes \bold{I} \otimes \bold{I} +
        \bold{I} \otimes \bold{D}_\bold{yy} \otimes \bold{I} +
        \bold{I} \otimes \bold{I} \otimes \bold{D}_\bold{zz}
\]

下面通过计算二维势箱内的电子能级来验证上面式子的正确性。

假设二维势箱是边长 $a = 1 \rm{Å}$ 的正方形，其中的电子满足 Schrodinger 方程：

\[\begin{aligned}
    -\frac{\hbar^2}{2m_e}(\frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}) \psi = E\psi
\end{aligned}\]

它的 Hamiltonian 只包含 Laplacian ，解析解为

\[\begin{aligned}
    E &={} (n_x^2 + n_y^2)\frac{h^2}{8ma^2} \newline
    \psi(x, y) &={} \frac{2}{a}\sin(\frac{n_x \pi x}{a}) \sin(\frac{n_y \pi y}{a})
\end{aligned}\]

程序实现如下：

#+begin_src julia
#!/usr/bin/env julia

using LinearAlgebra;
using SparseArrays;
using Arpack;
using Plots;

################################################################################
#
#                           Constants Part
#
################################################################################

const N = 200;                 # sample points
const len = 1.0;                # box length

const k = 3.8099821161548593;   # hbar^2 / (2*m_e) = (Å^2) / eV
const m = 1.0;                  # relative mass of electron

const nev = 8;                  # number of eigen values to be covered

x = LinRange(0.0, len, N);
y = LinRange(0.0, len, N);
const dx = len / N;
const dy = len / N;

################################################################################
#
#                           Hamiltonian Part
#
################################################################################

Tx = sparse(-2.0I, N, N);
Tx[diagind(Tx,  1)] .= 1.0;
Tx[diagind(Tx, -1)] .= 1.0;
Tx *= -k / (m * dx * dx);
Ix = sparse(1.0I, N, N);

Ty = sparse(-2.0I, N, N);
Ty[diagind(Ty,  1)] .= 1.0;
Ty[diagind(Ty, -1)] .= 1.0;
Ty *= -k / (m * dx * dx);
Iy = sparse(1.0I, N, N);

T_ = kron(Tx, Iy) + kron(Ix, Ty);

T = deepcopy(T_);
H = T;

println("Hamiltonian constructed, start solving ...");
@time λ, ϕ = eigs(H, nev=nev, which=:LM, sigma=0.0);
@show λ

################################################################################
#
#                           Visualization Part
#
################################################################################

for i in 1:nev
    ϕ[:,i] ./= norm(ϕ[:, i]) * dx   # Normalization
    @assert sum(ϕ[:, i].^2) * dx^2 ≈ 1.0    # verify the norm: ∫ |ϕ|² dx == 1
end

@show maximum(ϕ[:, 1])

ψ = reshape(ϕ, N, N, nev);

p1 = surface(x, y, ψ[:, :, 1], title="ψ_1");
p2 = surface(x, y, ψ[:, :, 2], title="ψ_2");
p3 = surface(x, y, ψ[:, :, 3], title="ψ_3");
p4 = surface(x, y, ψ[:, :, 4], title="ψ_4");
p = plot(p1, p2, p3, p4, layout=(2, 2), size=(800, 500));
savefig(p, "./2D-particle-in-a-box-eigvec.svg");
#+end_src

解得本征值与解析解对比如下：

| $\lambda$ | $n_x^2 + n_y^2$ | $E_{\rm numerical}$ (eV) | $E_{\rm analytical}$ (eV) |
|-----------+-----------------+--------------------------+---------------------------|
|         1 | 1 + 1 = 2       |                   74.458 |                    75.206 |
|         2 | 4 + 1 = 5       |                  186.136 |                   187.961 |
|         3 | 1 + 4 = 5       |                  186.136 |                   187.961 |
|         4 | 4 + 4 = 8       |                  297.814 |                   300.737 |
|         5 | 9 + 1 = 10      |                  372.236 |                   375.922 |
|         6 | 1 + 9 = 10      |                  372.236 |                   375.922 |
|         7 | 9 + 4 = 13      |                  483.914 |                   488.698 |
|         8 | 4 + 9 = 13      |                  483.914 |                   488.698 |

解得的本征值相差还是不小的，但总体趋势是一致的。
解得波函数如下（限于篇幅原因只列举前四个）:
[[./schrodinger-equation-numercial-methods/2D-particle-in-a-box-eigvec.svg]]

根据波函数形状判断，它们与量子数的对应关系如下：

| $\psi$ | $n_x$ | $n_y$ | $E$ (eV) |
|--------+-------+-------+----------|
|      1 |     1 |     1 |   74.458 |
|      2 |     2 |     1 |  186.136 |
|      3 |     1 |     2 |  186.136 |
|      4 |     2 |     2 |  297.814 |

在归一化波函数后，求得振幅为 1.990 ，与 $\dfrac{2}{a} = 2$ 相差无几。

由此可见，使用 Kronecker Sum 构造的 Laplacian 解出的结果是正确的。

***** 高维 Hamiltonian 的构造与求解

已经有了高维的 Laplacian ，我们需要把势能项和 Laplacian 组合起来得到 Hamiltonian 。
显然，我们需要把势能加到对角项上，但要注意一个问题，就是 Laplacian 的对角项与格点的对应关系：

\[
    L = \bold{D}_\bold{xx} \otimes \bold{I} \otimes \bold{I} +
        \bold{I} \otimes \bold{D}_\bold{yy} \otimes \bold{I} +
        \bold{I} \otimes \bold{I} \otimes \bold{D}_\bold{zz}
\]

我们不妨令 $\bold{D}_\bold{xx}$ 为 $\bold{X}$ ， $\bold{D}_\bold{yy}$ 为 $\bold{Y}$ ，
$\bold{D}_\bold{zz}$ 为 $\bold{Z}$，
根据 Kronecker Product 的运算过程（详见 Wiki），最后得到的矩阵对角线应该是

\[\begin{bmatrix}
\bold{X}_{11} \bold{Y}_{11} \bold{Z}_{11} & & & \newline
& \bold{X}_{11} \bold{Y}_{11} \bold{Z}_{22} & & \newline
& & \bold{X}_{11} \bold{Y}_{11} \bold{Z}_{33} & \newline
& & & & \ddots
\end{bmatrix}\]

上式中 $\bold{Z}$ 的对角线，即最后一个维度的下标增长得最快；对应地，在加和势能项时，
也应该是最后一个维度增长最快，这恰好是访问一个行主序的多维数组元素时的访问顺序。
也就是说我们只需要按照行主序的顺序把多维的势能数组展开为一维数组，然后加和到 Laplacian 上
即可得到 Hamiltonain ：

\[H = T +
\begin{bmatrix}
V_{111} & & & \newline
& V_{112} & & \newline
& & V_{113} & \newline
& & & \ddots
\end{bmatrix}\]

此处我们选取静态氢原子的电子为求解对象，它的 Shrodinger 方程是这个形式

\[
    -\frac{\hbar^2}{2m_e} \nabla^2 \psi - \frac{e^2}{4\pi \epsilon_0} \frac{1}{r} \psi = E\psi
\]

下面是程序实现，注意 Julia 的数组是列主序，因此在组合 Hamiltonian 时需要转换；
除此之外受计算机性能和辣鸡 =ARPACK= 的限制，这里每个维度只取 50 个点，每个维度各取 30Å 的长度。

#+begin_src julia
#!/usr/bin/env julia

using LinearAlgebra;
using SparseArrays;
using Arpack;
using WriteVTK;

# Auxiliary function
function mgrid(xs...)
    it = Iterators.product(xs...);
    ret = [];
    for i in 1:length(xs)
        push!(ret, getindex.(it, i));
    end
    return ret;
end


################################################################################
#
#                                Constants Part
#
################################################################################

const k   = 3.8099821161548593  # hbar^2 / (2*m_e) /(Å^2) / eV
const k_c = 14.39964547842567   # (e*e / (4 * np.pi * epsilon_0))  # measured in eV / Å
const m   = 1.0                 # mass of electron

const xlen = 30.0;
const ylen = xlen;
const zlen = xlen;

const N = 50;
const dx = xlen / N;

# generate the grid
const x = range(-xlen/2, xlen/2, length=N);
const y = range(-ylen/2, ylen/2, length=N);
const z = range(-zlen/2, zlen/2, length=N);

const nev = 10;

################################################################################
#
#                                Potential Part
#
################################################################################

gx, gy, gz = mgrid(x, y, z);
function potential(gx, gy, gz) ::AbstractArray
    r = sqrt.(gx.^2 + gy.^2 + gz.^2);
    r[r .< 0.0001] .= 0.0001;
    return -k_c ./ r;
end

V = potential(gx, gy, gz);
Vmin = minimum(V)


################################################################################
#
#                                Hamiltonian Part
#
################################################################################

# Kinetic part
Identity = sparse(1.0I, N, N);

T_ = sparse(-2.0I, N, N);
T_[diagind(T_,  1)] .= 1.0;
T_[diagind(T_, -1)] .= 1.0;

T_ .*= -k / (m * dx*dx)

T = kron(T_, kron(Identity, Identity)) +
    kron(Identity, kron(T_, Identity)) +
    kron(Identity, kron(Identity, T_));

# Hamiltonian
H = deepcopy(T);
H[diagind(H)] .+= permutedims(V, [3, 2, 1])[:];


# Solve the equation Hψ = Eψ
@time λ, ϕ = eigs(H, nev=nev, which=:LM, sigma=min(0, Vmin));
@show λ


################################################################################
#
#                                Visualization Part
#
################################################################################

vtk_grid("HydrogenAtom", x, y, z) do vtk
    for i in 1:nev
        ϕ[:, i] ./= norm(ϕ[:,i]) * dx * sqrt(dx);
        @assert sum(ϕ[:,i].^2) * dx^3 ≈ 1.0
        vtk["phi_$i"] = reshape(ϕ[:, i], N, N, N);
    end
end
#+end_src

结果与解析值对比

| $\lambda$ | $n$ | $E_{\rm numernical}$ (eV) | $E_{\rm analytical}$ (eV) |
|         1 |   1 |                   -10.713 |                     -13.6 |
|         2 |   2 |                    -3.417 |                      -3.4 |
|         3 |   2 |                    -3.417 |                      -3.4 |
|         4 |   2 |                    -3.417 |                      -3.4 |
|         5 |   2 |                    -3.031 |                      -3.4 |
|         6 |   3 |                    -1.515 |                     -1.51 |
|         7 |   3 |                    -1.515 |                     -1.51 |
|         8 |   3 |                    -1.515 |                     -1.51 |
|         9 |   3 |                    -1.474 |                     -1.51 |
|        10 |   3 |                    -1.474 |                     -1.51 |

本征值与解析值对应得并不好，尤其是基态的能量，与解析解相差了近 3eV ，这是因为 $1s$ 态主要局域在
原子核附近，而求数值解时每个维度只取了 50 个点，

本征态如下（这里只取前五个态）：

[[./schrodinger-equation-numercial-methods/3D-hydrogen-eigvec.png]]

它们分别对应氢原子的 $1s$ 态、 $2p_y$ 态、 $2p_z$ 态、 $2p_x$ 态和 $2s$ 态，抛去过于粗糙的格点和不太准的本征值不谈，
它们的形状与实验上符合得还是很好的。

以上结果可以证明 Hamiltonian 的构造是合理的。

*** 有限元法

**注：本人刚刚接触 FEM ，这里只是简单谈谈有限元法，以能通过改示例跑通自己的问题为标准
，因此对它的各项论述十分粗浅且可能存在错误，欢迎专业人士指正。**

上面我们讨论了使用有限差分法求解 Schrodinger 方程的过程，除了有限差分法，
还有一种在 CAE 领域应用非常广泛的方法——有限元法，也能用来求解 Schrodinger 方程。
简单且不负责任地说，有限元与有限差分最大的区别在于有限元的元素是大小、形状均可变，
并且它可以随意调整求解空间的形状以及网格的形状、局部疏密等等，
这使得它可以对各种奇怪的体系进行求解。

**** 定态 Schrodinger 方程的变分弱解形式
之前本文给出过定态 Schrodinger 方程

\[
    -\frac{\hbar^2}{2m}\nabla^2 \psi + V\psi = E\psi
\]

它其实是偏微分方程的 Strong Form （强解形式），而在 FEM 领域中常常使用 Weak Form
（弱解形式）来描述一个偏微分方程。经过查阅资料，我找到的 Shrodinger 方程的弱解形式如下：

\[\begin{aligned}
    \frac{\hbar^2}{2m} \int_{\Omega} \left(
    \frac{\partial u}{\partial x} \frac{\partial v}{\partial x} +
    \frac{\partial u}{\partial y} \frac{\partial v}{\partial y} +
    \frac{\partial u}{\partial z} \frac{\partial v}{\partial z}
    \right) + \int_{\Omega} Vuv = \int_{\Omega} Euv
\end{aligned}\]

上式中 $u$ 是我们要求解的波函数， $v$ 是测试函数， $\Omega$ 是有限元空间。
看起来这个式子和 Schrodinger 方程的强解形式差不多，只是动能项前面没有负号了。
具体推导过程详见 [[https://en.wikipedia.org/wiki/Weak_formulation#Example_2:_Poisson's_equation ][Weak formulation of Poisson's equation]] [fn:: https://en.wikipedia.org/wiki/Weak%5Fformulation#Example%5F2:%5FPoisson's%5Fequation%20]
或 [[https://en.wikiversity.org/wiki/User:Tclamb/FEniCS#Quantum_Harmonic_Oscillator][Weak formulation of quantum harmonic oscillator]] [fn:: https://en.wikiversity.org/wiki/User:Tclamb/FEniCS#Quantum%5FHarmonic%5FOscillator]。

**** 程序实现及结果验证
有了弱解形式的 Schrodinger Equation 后就可以开始使用有限元法求解了，这里使用
[[https://freefem.org][FreeFEM++]] [fn:: https://freefem.org] 作为实现语言。

使用 FreeFEM++ 求解本征值问题时主要有以下步骤：
1. 定义网格；
2. 定义有限元空间；
3. 定义需要解决的问题，即用代码表达弱解形式的偏微分方程；
4. 调用求解器求解；
5. 输出结果以及可视化结果等。

这里以求解氢原子为例，求解空间为 30Åx30Åx30Å 的正方体，边缘格点数为 40x40x40 ，使用 P1 有限元空间。
下面是代码

#+begin_src FreeFEM++
load "msh3"
load "iovtk"

int nn = 40;

real ka = 3.8099821161548593; // hbar^2 / 2m_e
real kc = 14.39964547842567; // e^2 / (4pi epsilon_0)

mesh3 Th = cube(nn, nn, nn, [30*x-15, 30*y-15, 30*z-15]);
plot(Th, wait=1);

fespace Vh(Th, P1);

cout << "Th :  nv = " << Th.nv << " nt = " << Th.nt << endl;

real sigma = -13;

macro Grad(u) [dx(u), dy(u), dz(u)] // EOM
varf a(u1, u2) = int3d(Th) (
    Grad(u1)' * Grad(u2) * ka
    - 1.0 / sqrt(x^2 + y^2 + z^2)  * u1 * u2 * kc
    - sigma * u1 * u2
    )
    //+ on(1, 2, 3, 4, 5, 6, u1=0.0)   // boundary condition
    ;

varf b([u1], [u2]) = int3d(Th) ( u1 * u2 ) ;

matrix A = a(Vh, Vh);
matrix B = b(Vh, Vh);

int nev = 20;
real[int] ev(nev);
Vh[int] eV(nev);

int k = EigenValue(A, B, sym=true, sigma=sigma, value=ev, vector=eV, tol=1e-10);

k = min(k, nev);

for (int i=0; i<k; ++i) {
    cout << " ---- " << i << " " << ev[i] << " == " << endl;
    plot(eV[i], cmm="#" + i + " EigenValue=" + ev[i], wait=true);
    savevtk("Eigen_" + i + ".vtk", Th, eV[i], dataname="EigenValue=" + ev[i]);
}
#+end_src

求得本征值如下：

| $\lambda$ | $E_{\rm numerical}$ (eV) | $E_{\rm analytical}$ (eV) |
|         1 |                  -10.390 |                     -13.6 |
|         2 |                   -3.163 |                      -3.4 |
|         3 |                   -3.163 |                      -3.4 |
|         4 |                   -2.980 |                      -3.4 |
|         5 |                   -2.776 |                      -3.4 |
|         6 |                   -1.475 |                      -1.5 |
|         8 |                   -1.475 |                      -1.5 |
|         7 |                   -1.444 |                      -1.5 |
|         9 |                   -1.444 |                      -1.5 |
|        10 |                   -1.423 |                      -1.5 |

可见在这个格点密度下它的精度还是不太高，有些态甚至还比不上有限差分法的精度。

它们的本征态如下：

[[./schrodinger-equation-numercial-methods/3D-hydrogen-eigenvec-FEM.png]]

和有限差分法相比，它的本征态似乎更粗糙一些，实际上这是由于取的网格不够密，
以及势能项 $1/r$ 在 0 处存在奇点难以近似导致的。

尽管有这样的缺陷，但它胜在是一个成熟的开源软件，比之前随便写的 toy 要正式许多，
而且它还能使用其它设计软件来建模定义求解的空间，甚至读取其它软件生成的网格进行后续的计算，
最重要的一点，它可以集成并行的本征值求解器 SLEPc [fn:: https://slepc.upv.es] 。
经过测试，求解一个 150x150x75 的网格时，在 32 核的服务器上可以用 18 分钟跑完，效率还是令人满意的。

*** 总结及吐槽

总之，本文使用了两种不同的方法在实空间直接求解单电子的 Schrodinger 方程，
总体的结果还算满意。有限差分法的算法学习自 GithHub 的一个项目
[[https://github.com/quantum-visualizations/qmsolve][qmsolve]] [fn:: https://github.com/quantum-visualizations/qmsolve]，
作者甚至还把我拉到了这个项目的 Discord 讨论群（现在已经开放）继续讨论。


**** 吐槽
1. 有限差分法的 Hamiltonian 矩阵大小随维度的升高而急剧升高，
   如果一个问题能在较低的维度解决，不要使用更高的维度，通常情况后者解不动：
   一维问题的 Hamiltonian 大小是 $O(N^2)$ ，而三维问题的 Hamiltonian 大小是 $O(N^6)$
   +，如果后面有空的话我会考虑写一下柱坐标系内 Schrodinger 方程的求解+ 。
2. 在使用有限差分法时格点越密，求解所需的时间越多，且耗时呈指数级增长。
   为此我花了将近一周多的时间在寻找 Julia 能用的并行本征值求解器上，
   最后发现没有能满足要求的，有几个 C++ / Python 能用的并行求解器，如 SLEPc 和 Trilinos ，但我没去尝试；
3.  =Arpack= 在处理 60x60x60 的格点时就已经有点力不从心了，
   超算上显示它只能通过调用 =BLAS= 来实现部分的并行操作，且最多只有 6 个线程在跑，
   而且 =Arpack= 也确实很久没有更新了；
4. =scipy.sparse.eigsh= 的效率还不如 Julia 里的 =Arpack.eigs= ，前者算 50x50x50
   的体系就算不动了，而且似乎在超算上用并行也没什么加速效果，尽管所有核都是满载；
5. FreeFEM++ 的语言乍一看挺像 C++ ，但其实区别还是相当大的，令人惊喜的是它的文档还有一个中文翻译版；
6. 在服务器上编译 FreeFEM++ 也花了我不少时间，这个东西的 Makefile 写得让人头疼：
   =configure= 文件直接就是一个 Python 脚本，而且层层套娃，想改什么参数都不好找，
   那两天被弄得脑壳疼；
7. FreeFEM++ 支持并行操作，用更密的 Mesh 可以重复出文献上的结果；更重要的是它可以更灵活地指定边界条件；
8. 在可视化 FreeFEM++ 的输出，即 vtk 文件时也遇到了不少麻烦，因为之前从没接触过 vtk 文件，
   只是听说 ParaView[fn:: https://www.paraview.org] 效果最好，于是从头开始学 ParaView 。
   不得不说，入门时还是看视频学最快，找谷歌翻论坛很可能不知所云；
9. 实验组最后还要求用求得的波函数计算一下位置算符的期望值，于是我又不得不去翻 ParaView 的手册找怎么操作数据。
   这个软件和 Python 以及 VTK 深度集成，里面自带一个 Python 解释器，
   但没有提供内置对象的文档，导致你面对一个 Script 框时连输入是啥都不知道，
   此外它的一些数据结构在原版 VTK 内还没有，那就只能靠 =dir(obj)= 来看它的方法列表了，
   通过不断地翻论坛（2018 年以前的论坛还是在邮件列表上），
   还是在一个人的回答中找到了相关的信息，算是顺利解决了问题，不得不说这个过程还是挺恶心人的。


这些东西可能读起来几分钟就读完了，但从接到相关的任务，到给出令实验组满意的结果，
再到写出这篇博文，整整用掉了一个多月的时间，这期间试了尝试过很多次，
不管是有限差分还是有限元，写过很多测试的代码但结果不正确，身边又没有可以请教人时，
内心还是有一点绝望的（尤其在 6 月下半旬还夹着报账那个事），
中途想过放弃，想着不如直接找个力学系的同学抛给他用 COMSOL 解出来，
但最后还是通过翻论坛，厚着脸皮问 developer 等手段把想要的结果算出来了，
此时觉得前面的努力还是没有白费，就是对当初对实验组的老师打包票说几天就能算出来，
但实际花了近一个月这一点还是有点惭愧的。

** DONE 简易 DFT 玩具 :@Physics:Julia:FiniteDifferenceMethod:DensityFunctionalTheory:
CLOSED: [2022-08-14 Sun 22:13]
:PROPERTIES:
:EXPORT_FILE_NAME: simple-dft-toy
:EXPORT_DATE: [2022-08-05]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :mathjax true :markup goldmark
:END:

一直在用别人写好的 DFT 软件，对软件的运行过程略有兴趣，查阅资料弄懂了一些运行原理并参考
了前人的程序后，这次我们来自己写一个 DFT 的玩具～

#+hugo: more

*首先感谢一个 GitHub 上的仓库，为本文的代码提供了参考[fn:: tamuhey 的代码 https://github.com/tamuhey/python_1d_dft]。*

*** 理论基础
我们的目标是求解 Kohn-Sham 方程。

对于 Kohn-Sham 方程，系统的能量包含下面几个部分

\[
E[\rho] = T_s[\rho] + \int d\mathbf r v_\text{ext}(\mathbf r) \rho(\mathbf r) + E_\text{Ha} [\rho] + E_\text{xc}[\rho]
\]

其中 \(T_s\) 是 Kohm-Sham 动能项，它的表达形式为

\[
T_s[\rho] = \sum_{i=1}^{N} \int d\mathbf r \varphi^*(\mathbf r) \left( -\frac{\hbar^2}{2m}
\nabla^2 \right) \varphi_i(r)
\]

\(v_\text{ext}(\mathbf r)\) 是外场作用在系统所有电子上的势能，这里“外”是指除所研究电子以外，
电子与原子核的相互作用也算在这一项内；

\(E_\text{H}[\rho]\) 为 Hartree 能，也就是电子-电子的库仑相互作用项

\[
E_\text{H}[\rho] = \frac{e^2}{8\pi\epsilon} \int d\mathbf r \int d\mathbf{r'} \frac{\rho(\mathbf r)
\rho(\mathbf {r'})}{|\mathbf r - \mathbf{r'}|}
\]

\(E_\text{xc}[\rho]\) 是交换关联能，这里为了简便处理，只使用 LDA 近似处理交换项，忽略关联项。
在 LDA 近似下

\[
E_\text{x}^\text{LDA}[\rho] = -\frac 34 (\frac 3\pi)^{1/3} \int \rho^{4/3} d \mathbf r
\]

上面式子中 \(\rho\) 代表系统的电子密度，它是通过下面方式计算得到：
令一系列正交归一的占据态电子轨道为 \(\varphi_i\)，则体系的电子密度为
\[
\rho(\mathbf r) = \sum_i^N |\varphi_i(\mathbf r)|^2
\]

上面的式子表示的都是能量，现在将它们对应到 Kohn-Sham 方程的 Hamiltonian 中

\[
\hat{H}_\text{KS} \Psi = E_\text{KS} \Psi
\]

- 显然动能算符是 \(-\frac{\hbar^2}{2m}\nabla^2\)
- 外场作用算符为 \(v_\text{ext}(\mathbf r) = \frac{\delta \int d\mathbf r v_\text{ext}(\mathbf r) \rho(\mathbf r)}{\delta \rho}\)
- Hartree 作用算符为 \(v_\text{Ha}(\mathbf r) = \frac{\delta E_\text{Ha}[\rho]}{\delta \rho}
  = \frac{e^2 \Delta V}{4\pi \epsilon} \int\frac{\rho(\mathbf r')}{\sqrt{(\mathbf r - \mathbf r')^2}} d\mathbf r'\)
- 交换项算符为 \(v_\text{x}(\mathbf r) = \frac{\delta E_\text{x}[\rho]}{\delta \rho} = -(\frac 3\pi)^{1/3} \rho^{1/3}\)

此时 KS 方程和 Hamiltonian 可以展开为

\[\begin{aligned}
\hat{H}_\text{KS} &={} -\frac{\hbar^2}{2m}\nabla^2 + v(\mathbf r) \\
                  &={} -\frac{\hbar^2}{2m}\nabla^2 + v_\text{ext}(\mathbf r) +
                        v_\text{Ha}(\mathbf r) + v_\text{x}(\mathbf r) \\
                  &={} -\frac{\hbar^2}{2m}\nabla^2 + v_\text{ext}(\mathbf r) +
                    \frac{e^2}{4\pi \epsilon} \int\frac{\rho(\mathbf r')}{\sqrt{(\mathbf r - \mathbf r')^2}} d\mathbf r'
                    -(\frac 3\pi)^{1/3} \rho^{1/3}
\end{aligned}\]

将 KS 方程的 Hamiltonian 写成矩阵形式，并对角化，即可得到 KS 轨道 \(\varphi_i\) 和它们对应的能量 \(E_i\) 。

*** 程序实现

为方便起见，这里依然使用 Julia 来实现，请确保机器上的 Julia 已经装上了 Arpack 和 Plots 库。

#+begin_src julia
using LinearAlgebra
using Arpack
using Printf
using PlotlyJS
#+end_src

同时既然是玩具，这里就在一维的空间里计算电子的波函数。这里用到的大部分基础知识在上篇文章
《使用数值方法求解单电子 Schrodinger 方程》 里都能找到（尤其是一维势箱模型系统的求解部分），
因此下面的介绍会有所简化。

这里在 $[-5, 5]$ 之间均匀取 200 个格点来表示整个系统所在的空间。

#+begin_src julia
ngrid = 200
x = LinRange(-5, 5, ngrid)
#+end_src

**** $\nabla^2$ 的矩阵表示
这个算符的矩阵表示在上一篇博客里已经讲过了，这里不再赘述:

\[
\frac{d^2}{dx^2} = \frac{1}{\Delta x^2} \begin{bmatrix}
    -2 & 1 &   &  &   \newline
     1 & -2 & 1 &  &   \newline
      & 1 & -2 & \ddots &   \newline
      &   & \ddots & \ddots  & 1 \newline
      &   &   & 1 & -2
\end{bmatrix}
\]

写成代码的形式即为

#+begin_src julia
Δx = x[2] - x[1]
∇² = Tridiagonal(ones(ngrid-1), -2*ones(ngrid), ones(ngrid-1)) ./ (2*Δx)
#+end_src

#+RESULTS:

**** 势能的表示
一般情况下， Hamiltonian 里势能部分的贡献直接体现在对角线上，这里只给出一维形式的势能函数，然后会在
所有势能计算好后一并加到 Hamiltonian 里。除此之外，由于取了模型势，电子质量和一些物理常数就直接取为 1 ，比如
$\frac{e^2}{8\pi\epsilon}$ 和 $\frac{\hbar^2}{2m_e}$ 等。

***** 外场势能 $v_\text{ext}(\mathbf r)$

这里我们选择三个外场模型：无相互作用系统、无限深势阱系统和谐振子系统。

****** 一维势箱系统
在没有周期性边界条件的情况下， $v_\text{ext}(x) = 0$

****** 无限深势阱系统
这里的“无限深”也等价于周围的墙壁无限高，即
\[
    v_\text{ext}(x) = \begin{cases}
        \infty & x < -d \\
        0 & -d \le x \le d \\
        \infty & x > d
    \end{cases}
\]
其中 $d$ 就是中间势阱宽度，程序中取为 2 。 由于程序中无法直接表示值 $\infty$ ，因此使用一个非常大的正实数来代替，
这里取 $1.0\times 10^10$ 这个值。

#+begin_src julia
V_well = fill(1e10, ngrid)
@. V_well[-2 <= x <= 2] = 0
#+end_src

#+RESULTS:

****** 谐振子系统
谐振子系统的势能是一条抛物线
\[
    v_\text{ext}(x) = kx^2
\]

出于简化的目的，这里 $k$ 直接取为 1 。

#+begin_src julia
V_harm = x.^2
#+end_src

以上三种势能函数画出来如下图所示：

[[./simple-dft-toy/simple-dft-potentials.svg]]

***** 电子密度 $\rho(\mathbf r)$
Kohn-Sham 方程中包含电子之间库仑相互作用项（也称作 Hartree 项），和交换关联项，
而这两者都是电子密度的泛函，因此需要计算电子密度函数 $\rho(\mathbf r)$ ：

首先应保证每个电子的波函数是正交归一的

\[
\langle \phi_i | \phi_i \rangle = 1
\]

然后电子密度函数为

\[
\rho(x) = \sum_n f_n |\phi(x)|^2
\]

其中 $f_n$ 表示第 $n$ 个能级上的电子占据数，本文的体系目前暂不考虑电子的自旋，故
$f_n$ 的最大值可达到 2 。

根据上面公式，可以写出下面的代码

#+INCLUDE: "./simple-dft-toy/main.jl" src julia :lines "9-23"

我们求解不包含库仑势和交换关联势的 Schrodinger 方程后，求得波函数和电子密度如下图所示

[[./simple-dft-toy/simple-dft-psi_rho.svg]]

***** 库仑势 $v_\text{Ha}(\mathbf r)$

库仑势的公式为：

\[
v_\text{Ha}(x) = \frac{e^2 \Delta x}{4\pi \epsilon} \int\frac{\rho(x')}{\sqrt{(x - x')^2}} dx'
\]

在程序实现时，限于积分精度和除零的问题，分母中的 $\sqrt{(x - x')^2}$ 需要加上一个小量 $\varepsilon$
避免除零的出现

\[
v_\text{Ha} = \int \frac{n_j \Delta x}{\sqrt{(x - x')^2 + \varepsilon}} dx'
\]

#+INCLUDE: "./simple-dft-toy/main.jl" src julia :lines "24-30"

***** 交换关联势
首先忽略关联势，使用 LDA 近似，得到交换势为

\[
v_\text{x}^\text{LDA}[\rho] = -\sqrt[3]{3\rho / \pi}
\]

那么使用代码表示出来就很简单了：

#+INCLUDE: "./simple-dft-toy/main.jl" src julia :lines "31-36"

**** Hamiltonian 的构造

上面说到 Hamiltonian 里势能的部分体现在对角线上

\[\hat{H} = \frac{1}{(\Delta x)^2}
\begin{bmatrix}
    -2 & 1 &   &  &   \newline
     1 & -2 & 1 &  &   \newline
      & 1 & -2 & \ddots &   \newline
      &   & \ddots & \ddots  & 1 \newline
      &   &   & 1 & -2
\end{bmatrix} +
\begin{bmatrix}
V_1 & & & \newline
& V_2 & & \newline
& & \ddots & \newline
& & & V_n
\end{bmatrix} \]

用代码写出来

#+INCLUDE: "./simple-dft-toy/main.jl" src julia :lines "37-49"

对这个 Hamiltonian 对角化，可以得到一系列波函数 $\phi_i(x)$ 。

#+begin_src julia
E, ψ = eigs(H, nev=nlevel, which=:LM, sigma=0)  # 这个函数需要 using Arpack
#+end_src

**** KS 方程的迭代求解
电子密度 $\rho(x)$ 依赖于波函数 $\phi_i(x)$ ，而求解 $\phi_i(x)$ 所用的 Hamiltonian 又反过来依赖于 $\rho(x)$ ，
这意味着我们不能一次性求得正确的波函数 $\phi_i(x)$ ， 因此我们需要用迭代的方法来求解：

1. 先猜一个初始电荷密度 $\rho(x)$ ；
2. 用 $\rho(x)$ 构造 Hartree 势和交换关联势，然后构造 Hamiltonian ；
3. 对角化 Hamiltonian 求得本征值 $E_i$ 和波函数 $\phi_i(x)$ ；
4. 判断此次求得本征值 $E_i$ 与上一次结果相差是否足够小，如果是，则停止计算，否则进入第 5 步；
5. 使用波函数 $\phi_i(x)$ 构造电子密度 $\rho(x)$ ，并返回第 2 步。

上面的过程也叫做自洽迭代(self-consistency loop)。

到这一步，我们把所有代码整合起来运行一下，便能得到一个简易的 DFT 玩具

#+INCLUDE: "./simple-dft-toy/main.jl" src julia

它运行时会出现下面的日志输出（以 \(V_\text{ext} = V_\text{empty}\) 为例）：

#+begin_src text
step:     1 E:   191.3250 ΔE           -Inf
step:     2 E:   188.6149 ΔE  -2.7101725428
step:     3 E:   189.9835 ΔE   1.3686497726
step:     4 E:   189.2422 ΔE  -0.7413493772
step:     5 E:   189.7313 ΔE   0.4891692181
step:     6 E:   189.4190 ΔE  -0.3123247101
step:     7 E:   189.6381 ΔE   0.2191170430
step:     8 E:   189.4893 ΔE  -0.1488193569
step:     9 E:   189.5950 ΔE   0.1057145189
step:    10 E:   189.5214 ΔE  -0.0735956265
step:    11 E:   189.5738 ΔE   0.0523625987
step:    12 E:   189.5369 ΔE  -0.0368426628
step:    13 E:   189.5631 ΔE   0.0262003363
step:    14 E:   189.5446 ΔE  -0.0185224236
step:    15 E:   189.5578 ΔE   0.0131633325
step:    16 E:   189.5484 ΔE  -0.0093260810
step:    17 E:   189.5551 ΔE   0.0066245797
step:    18 E:   189.5504 ΔE  -0.0046981797
step:    19 E:   189.5537 ΔE   0.0033362576
step:    20 E:   189.5513 ΔE  -0.0023672119
step:    21 E:   189.5530 ΔE   0.0016807098
step:    22 E:   189.5518 ΔE  -0.0011928024
step:    23 E:   189.5527 ΔE   0.0008468043
step:    24 E:   189.5521 ΔE  -0.0006010437
step:    25 E:   189.5525 ΔE   0.0004266762
step:    26 E:   189.5522 ΔE  -0.0003028617
step:    27 E:   189.5524 ΔE   0.0002149933
step:    28 E:   189.5523 ΔE  -0.0001526097
step:    29 E:   189.5524 ΔE   0.0001083320
step:    30 E:   189.5523 ΔE  -0.0000768987
step:    31 E:   189.5523 ΔE   0.0000545872
step:    32 E:   189.5523 ΔE  -0.0000387486
step:    33 E:   189.5523 ΔE   0.0000275059
step:    34 E:   189.5523 ΔE  -0.0000195251
step:    35 E:   189.5523 ΔE   0.0000138599
step:    36 E:   189.5523 ΔE  -0.0000098385
converged!
#+end_src

和前面一样，把波函数和电子密度函数画出来，如下图所示：

[[./simple-dft-toy/simple-dft-psi_rho_dft.svg]]

下面以 \(V_\text{empty}\) 为例，对比一下原来的波函数与 DFT 方法算出的 KS 波函数的变化：

[[./simple-dft-toy/simple-dft-psi_org_dft.svg]]

可以看到， KS 波函数的空间分布与原来无相互作用波函数空间分布差别很大， KS 波函数的波包的顶点
都发生了偏移，说明库仑相互作用和交换相互作用影响较大。例如 \(\psi_1\) ，无相互作用体系里波函
数分布最大的地方在 \(x=0\) 处，但 KS 波函数里空间分布最大的地方在 \(x=\pm 4.2\) 处左右，表明
其它能级更高的电子对它的分布也产生了显著的影响。除此之外，波函数的本征值也变化巨大。实际上这里
的对比不太严谨：原来无相互作用体系的波函数是一个电子在不同能级的波函数，而 KS 波函数则
被当成是一个含有 N 个电子的体系里每个电子的波函数，这两者概念上的差异不能忽略。

需要注意的是，尽管我们习惯用 KS 轨道表示真实体系里每个电子的轨道，但 KS 轨道实质上仍是单粒子
Schrodinger 方程的解，它能否代替体系真实的波函数仍需要 check ，本人不认为这两者等价。比如在
 Ren Xinguo 老师的课件[fn:: 任老师的课件 http://lqcc.ustc.edu.cn/renxg/plus/list.php?tid=7]
 里是这样描述的

#+BEGIN_QUOTE
KS orbitals are auxiliary variables, and have no strict physical meaning (except for HOMO and LUMO).
#+END_QUOTE
即除了 HOMO 和 LUMO 之外， KS 波函数仅仅作为计算电子密度函数 \(\rho(\text r)\) 的辅助函数之用。
HOMO 和 LUMO 在一定程度上可以视作体系的真实轨道，此时体系的第一电离能即为 HOMO 的能量（Janak theorem, 1978）：

\[
I = E_0(N-1) - E_0(N) = -\epsilon_N
\]

下面来看一下电子密度函数的变化：

[[./simple-dft-toy/simple-dft-rho_org_dft.svg]]

很明显，经过自洽迭代后，体系的电子密度分布也发生了变化，对比占据态轨道的变化而言，电子密度的变化还是比较小的。

如果考虑电子的自旋，我们需要修改交换关联泛函，即使用考虑电子自旋的 LSDA 泛函，此时体系的波函数
表示也需要随之修改， \(\psi_i(x)\) 变为 \(\psi_i(x, \sigma)\) ，即增加了一个自旋维度 \(\sigma\) 。
具体的泛函形式比较复杂，这里作为一个 toy 介绍就不展开了，如果有兴趣可以去看 [[http://lqcc.ustc.edu.cn/renxg/plus/list.php?tid=7][Ren Xinguo 老师的课件]]。

*** 总结与拓展

我们实现了一个简单的 DFT 计算程序，它可以使用自定义的外场势能函数，考虑 Hartree 势，并使用 LDA 近似。
通过求解 KS 方程，我们得到了 KS 波函数，并与无相互作用体系的波函数作对比，发现波函数的分布发生了显著
的变化，同时波函数的能量也发生了不小的变化。在实现的过程中，本人对那句“通过 DFT 将多体系统映射到单粒子系统”
可能有了一些很浅薄的理解。

尽管这是一个很简单的 toy ，但它也是包含了 DFT 计算所需的各种常见操作，比如构造电子密度函数，比如自洽迭代
求解 KS 方程，再比如求 Hartree 势函数、使用 LDA 近似等等，这些都可以在常见的 DFT 软件里找到，那么此次 DIY 的
过程也能加强对其它成熟 DFT 软件里运行时做了什么有了大概了理解。如果有人想要进一步拓展这个 toy ，我想到了以下几个方向：

- 考虑上下自旋，使用 LSDA 近似
- 使用 GGA 泛函（比如 PBE 泛函）
- 考虑外加电场，这个比较好办，直接在修改外场势函数即可
- 考虑外加磁场，这个需要修改 Hamiltonian 中的动能项表达式，添加矢势项
- 考虑相对论效应，使用 Dirac 方程代替 Schrodinger 方程，看是否能算出自旋轨道耦合效应
- ......

出于精力限制，本人可能没动力继续往下扩展，读者如果有兴趣，可以自行尝试。

** DONE 利用 Const Generics 实现编译期量纲分析 :@Programming:Rust:ConstGenerics:
CLOSED: [2023-02-27 Mon 22:39]
:PROPERTIES:
:EXPORT_FILE_NAME: dimensional-analysis-using-const-generics
:EXPORT_DATE: [2023-02-27 Mon]
:END:

开学前折腾了一段时间的 Rust const generics ，也读了一些前人的代码，并自己写出了自己的编译期量纲分析代码，
因此吸收总结这一过程所得知识，产生了这篇博文。

#+hugo: more

*** 什么是量纲分析
这里浅薄地介绍一下什么是量纲分析。贴一下 Wiki 上关于量纲和量纲分析的定义：

1) 量纲是表示一个物理量由基本量组成的情况。确定若干个基本量后，每个派生量都可以表示为基本量的幂的乘积的形式，
   引入量纲分析可以进行量纲分析，这既是物理学的基础，又有很多重要的应用。通常一个物理量的量纲是由像质量、
   长度、时间、电荷量、温度一类的基础量纲结合而成；
2) 量纲分析是指对数学或者物理学中物理量的量纲可以用来分析或检验几个物理量之间的关系。
   在判断一个由推导获得的方程式或计算结果是否合理时，可以对等号两边的量纲进行化简，从而确认是否一致，这个过程
   即用到了量纲分析。对于较为复杂的情况，量纲分析也可以用来建立合理的假设，然后用严格的实验加以验证，或用已
   发展成功的理论来仔细推敲。

由于目前的基本物理量有七个，故在量纲中分别用七个字母表示它们的量纲，分别为：

- 长度（L）
- 质量（M）
- 温度（Θ）
- 电流（I）
- 时间（T）
- 物质的量（N）
- 发光强度（J）

任何一个物理量 \(A\) 都可以写出下列量纲式：
\[
    \text{dim} A = L^{\alpha} M^{\beta} \Theta^{\gamma} I^{\delta} T^{\epsilon} N^{\zeta} J^{\eta}
\]
如果一个物理量的量纲中所有的指数为 0 ，那么称它为无量纲量，常见的无量纲量有精细结构常数 \(\alpha \approx 1/137\) 、
雷诺数 \(\text{Re} = \frac{\rho VL}{\mu} = \frac{VL}{\nu}\) 以及各种比值、概率等。
两个物理量量纲一致是它们能够相加减的必要条件，而不是充要条件，比如力矩和能量的量纲都是 $F \cdot L$ ，但这两个量
显然无法相加减。物理量的乘除乘方开方则没有这个限制，直接按照相应的代数运算法则对各个基本量纲处理再化简即可。

值得注意的是，能放在指数和真数位置上的物理量一定是无量纲量。回想一下统计力学中几乎无处不在的
\( \frac{E}{k_{\mathrm{B}} T}\) ，其中分母 \(k_B T\) 的量纲是能量，刚好与分子上 \(E\) 相抵消，导致指数整体是
一个无量纲量，进而使得 \( \frac{E}{k_{\mathrm{B}} T}\) 这个整体也是一个无量纲量；又比如在化学反应中常见的公式
\(\Delta G = \Delta G^{\ominus} + RT \ln K\) ，其中化学平衡常数 \(K\) 处于真数的位置，它一定是一个无量纲量。

此时，我们可以大致总结一下量纲分析运算的规则：
1) 物理量的量纲由 7 个基本量纲构成；
2) 具有相同量纲的物理量才能相加减；
3) 物理量在乘除、乘方和开方时基本量纲的指数遵循代数运算法则；
4) 处于指数、真数位置的物理量是无量纲量。

这些规则是我们程序实现量纲分析的参考。

*** 什么是 Const Generics
Const generics 翻译过来即为常量泛型。在涉及 Rust 泛型代码时，如果泛型参数是一个常量值，而不是类型或
生命周期参数等，那么这个泛型参数就称为常量泛型参数。例如下面一段代码就用到了泛型参数
#+begin_src rust
struct Position<T, const N: usize> {    // N 即为常量泛型参数
    pos: [T; N]
}
#+end_src
上面代码中 =const N: usize= 中的 =const= 前缀很贴心地告诉你后面的 =N= 是一个泛型参数，而 =: usize= 则表明
=N= 的类型是 =usize= 。这段代码定义了一个泛型的 =struct= ，其中包含一个名为 =pos= 的数组成员，这个数组元素
的类型由 =T= 决定，而长度由常量泛型参数 =N= 决定。注意，这里面的 =T= 和 =N= 都是编译期参数，也就是说它们在
编译期就已经确定，由于 Rust 是一门静态语言，所有变量的类型在编译成机器码时都是可以被推导出来的，
我们不能用一个程序运行期的变量（比如一个用户输入的值）作为 =T= 或 =N= ，这是不被允许，并且编译器
也无法做到的

那么 Rust 为什么要添加 =const generics= 这个特性呢？其中的原因在 [[https://rust-lang.github.io/rfcs/2000-const-generics.html][RFC#2000]] 已经写得很清楚了，简单来说就是
Rust 将 =[T; 1]= 、 =[T; 2]= 、 =[T;3]= ……这样不同长度的数组看做不同的类型，那么在实现一些操作时就会显得
很脏，比如[[https://doc.rust-lang.org/1.37.0/std/primitive.array.html#impl-Eq][早期版本的 Rust 标准库]]在实现比较两个定长数组是否相等的特质 =Eq= 时就分别对 =[T; 0]= 、 =[T; 1]= 、
 =[T; 2]= 等等的定长数组各自实现，一直到 =[T; 32]= 。那么如果你有一个长度大于 32 的定长数组需要比较时怎么办？
比如这样的代码
#+begin_src rust
fn compare(lhs: &[i32; 33], rhs: &[i32; 33]) -> bool {
    lhs == rhs
}
#+end_src
编译器会直接报错罢工，而如果把两个 =33= 全部换成 =32= 则可以正常编译，是不是感觉非常不可思议？当然这个问题在 2021
年 3 月份 [[https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html][const generics 稳定后]]就已经被解决了。在 Rustc 1.51 以后，你可以对任意长度的 =[T; LEN]= 运行比较，以及
其它相关的操作，再也不用担心编译器摆烂。

除了解决定长数组的相关问题， const generics 还有其它很多有用的地方，比如可以实现编译期的计算（写 C++
的同学可能已经开始狂喜了，别高兴太早，用 +Ruast+ 的 const generics 来写类似 C++ 的模板元编译期计算会非常地痛苦，
建议不要尝试）等。有一个相对关键的点在于，泛型参数只存在于编译期，也就是说在运行期这个参数不存在。这也意味着
常量泛型参数自己并不占内存，比如
#+begin_src rust
struct Foo<const N: usize> {
    value: i64,
}
#+end_src
这个结构体的大小用 =std::mem::size_of::<Foo<1>>()= 求出来是 =8= ，正好等于 =i64= 本身的大小；事实上，不管
=N= 取多少，甚至 =std::mem::size_of::<Foo<114514>>()= ，得到的仍然是 =8= ，这为编译器的优化提供了可能。

除此之外，当 =N= 不同时， =Foo<N>= 被认为是不同的类型。即使你分别为 =Foo<N1>= 和 =Foo<N2>= 分别实现了相同的
特质（这里以 =Eq= 为例），那么当你写下 =Foo::<N1>::default() == Foo::<N2>::default()= 这样的代码时，除非 =N1 == N2=
否则编译器会报错提醒你：
#+begin_src rust
#[derive(Default, PartialEq, Eq)]
struct Foo<const N: usize> {
    value: i64,
}

fn main() {
    println!("{}", Foo::<0>::default() == Foo::<1>::default());
}
// error[E0308]: mismatched types
//  --> src/main.rs:7:43
//   |
// 7 |     println!("{}", Foo::<0>::default() == Foo::<1>::default());
//   |                                           ^^^^^^^^^^^^^^^^^^^ expected `0`, found `1`
//   |
//   = note: expected struct `Foo<0>`
//              found struct `Foo<1>`
#+end_src
这个特性对于实现编译期量纲分析是至关重要的，可以说如果没有这个特性，编译期的量纲分析就无法实现。

*** 如何使用 Const Generics 实现量纲分析
在阐述如何使用 const generics 实现编译期量纲分析之前，我们先来了解一下运行期量纲分析有啥缺点。

为了描述量纲，我们需要定义一个结构体来储存七个基本量纲的指数，为了方便实现，这里直接取国际单位制：
#+begin_src rust
#[derive(Default, PartialEq, Eq)]   // make SiUnit::default() and SiUnit == SiUnit possible
pub struct SiUnit {
      m: i8,    // meter
      s: i8,    // second
     kg: i8,    // kilogram
      c: i8,    // coulomb
     cd: i8,    // candela
    mol: i8,    // mole
      k: i8,    // kelvin
}

impl SiUnit {
    pub fn new() -> Self {
        SiUnit::default()
    }
}
#+end_src

然后这个结构体需要实现加减运算特质，以满足两个物理量乘除时对量纲的运算：
#+begin_src rust
use std::ops::{Add, Sub, Mul, Div};   // required trait for overload of `+` and `-`.

impl Add for SiUnit {
    type Output = Self;     // required associate type
    fn add(self, rhs: Self) -> Self::Output {
        SiUnit {
              m: self.m    + rhs.m,
              s: self.s    + rhs.s,
             kg: self.kg   + rhs.kg,
              c: self.c    + rhs.c,
             cd: self.cd   + rhs.cd,
            mol: self.mol  + rhs.mol,
              k: self.k    + rhs.k,
        }
    }
}

impl Sub for SiUnit {
    type Output = Self;     // required associate type
    fn sub(self, rhs: Self) -> Self::Output {
        ...
    }
}
#+end_src

这样我们就可以直接执行 =SiUnit + SiUnit= 、 =SiUnit - SiUnit= 这样的操作了。

为了实现物理量的乘方开方运算，它还需要实现 =Mul= 和 =Div= 特质，与实现 =Add=
和 =Sub= 特质不同的是， =Mul= 和 =Div= 特质里的右操作数 =Rhs= 都是 =i8=
类型，而不是 =SiUnit= 本身，因为乘方开方的指数都是没有量纲的。
#+begin_src rust
use std::ops::{Mul, Div};

impl Mul<i8> for SiUnit {
    type Output = Self;
    fn mul(self, rhs: i8) -> Self::Output {
        SiUnit {
              m: self.m    * rhs,
              s: self.s    * rhs,
             kg: self.kg   * rhs,
              c: self.c    * rhs,
             cd: self.cd   * rhs,
            mol: self.mol  * rhs,
              k: self.k    * rhs,
        }
    }
}

impl Div<i8> for SiUnit {
    type Output = Self;
    fn div(self, rhs: i8) -> Self::Output {
        SiUnit {
            ...
        }
    }
}
#+end_src

此时， =SiUnit= 可以进行 =SiUnit * 2= 、 =SiUnit / 2= 这样的运算了。那么把和一个值打包在一起就组成一个
物理量了：
#+begin_src rust
pub struct PhysicalQuantity<T> {
    value: T,
    unit:  SiUnit,
}
#+end_src
然后我们再为它实现各种运算操作，就可以用它代入各种公式求值了。那么这其中有什么问题呢？

1) 它占用的内存太多。用 =std::mem::size_of::<PhysicalQuantity<f64>>()= 查看一下这个结构体占用的内存，
   为 16 字节，这说明不参与值运算的 =unit= 成员就占用了一半的空间；如果对一个 =[PhysicalQuantity; len]=
   这样的数组运算，那么所有元素的 =unit= 成员就交错分布在真正需要运算的 =value= 成员中间，这对 CPU
   的缓存命中和 SIMD 优化是非常不利的，进而造成可观的性能损失；
2) =PhysicalQuantity= 之间没有区分，也就是说 =unit= 不同的 =PhysicalQuantity= 被认为是同一个类型，
   当它们被放在同一个数组等线性表里时，编译器不会报错，而且人工检查也只能在运行时进行；
3) =PhysicalQuantity= 在执行加减运算时需要手动检查 =unit= 是否一致；在执行乘除法时，需要对 =unit= 运行相应
   的运算，这些均在运行时进行，并且每个元素操作时都要做，这也会严重降低运行效率。
